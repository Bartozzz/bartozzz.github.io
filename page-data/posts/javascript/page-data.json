{"componentChunkName":"component---src-templates-blog-posts-tsx","path":"/posts/javascript/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://laniewski.me"}}},"pageContext":{"keyword":"JavaScript","data":[{"id":"b5bffd9c-b881-59b9-9dd2-4f093bc69ba1","body":"\nBarrel files consolidate the exports of multiple modules into a single file. We use them to import a module using a single import statement without worrying about the underlying folder structure.\n\nHave a look at the following example of a `Modal` component:\n\n```\n/components\n└── /Modal\n    ├── Modal.js\n    ├── ModalHeader.js\n    ├── ModalContent.js\n    └── ModalFooter.js\n```\n\nA barrel would be an `index.js` file at `./components/Modal` with the following definition:\n\n```js\nexport { Modal } from \"./Modal\";\nexport { ModalHeader } from \"./ModalHeader\";\nexport { ModalContent } from \"./ModalContent\";\nexport { ModalFooter } from \"./ModalFooter\";\n```\n\nIt allows us to write a single import statement, such as:\n\n```js\nimport { Modal, ModalHeader, ModalContent, ModalFooter } from \"./Modal\";\n```\n\n…instead of:\n\n```js\nimport { Modal } from \"./Modal/Modal\";\nimport { ModalHeader } from \"./Modal/ModalHeader\";\nimport { ModalContent } from \"./Modal/ModalContent\";\nimport { ModalFooter } from \"./Modal/ModalFooter\";\n```\n\nAt first glance, barrel files look promising! Barrel files can improve code organization and make imports cleaner, especially in larger projects with many modules. But there’s a hidden cost.\n\n## The bundle size cost\n\nIf you target a no-build architecture or don’t have [tree-shaking](/blog/2018-04-29-publishing-packages-to-npm/) enabled in your bundler, all the files imported in the barrel file will get bundled into the application, even when unused! It results in tons of dead code, which can impact loading times.\n\nLet’s have a look at the following application, which renders a simple `Button` component from the [Material Design component library](https://mui.com/material-ui/):\n\n```jsx\nimport { Button } from \"@mui/material\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\n> node scripts/build.js\n\nCreating an optimized production build...\nCompiled successfully.\n\nFile sizes after gzip:\n\n  151.47 kB build/static/js/main.js\n```\n\nNow let’s import the `Button` component directly, skipping the barrel file:\n\n```diff\n-import { Button } from \"@mui/material\";\n+import Button from \"@mui/material/Button\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\n> node scripts/build.js\n\nCreating an optimized production build...\nCompiled successfully.\n\nFile sizes after gzip:\n\n  75.69 kB (-75.77 kB)  build/static/js/main.js\n```\n\n<Alert type=\"success\">\n  When not using a barrel file, the build size <u>decreased from ~151 kB to ~75 kB</u>.\n</Alert>\n\n<Alert type=\"info\">\n  Fortunately, most bundlers have tree shaking enabled by default because it reduces bundle size without changing the code behavior.\n</Alert>\n\n## The build-time cost\n\nBarrel files are one of the key reasons why tooling is slow in bigger projects. All of your modules are likely to load barrel files (the imports are nice, after all), and so are your modules hidden behind the barrel files. It can result in a graph of import statements, where each module depends on another one, and so on.\n\nThe more files, the longer it takes for the bundler to resolve and manage them. Here are the execution times of the build script for both variants:\n\n- **With barrel file:**\n\n```jsx\nimport { Button } from \"@mui/material\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\nExecution time: 0h:00m:10s sec\n```\n\n- **Without barrel file:**\n\n```diff\n-import { Button } from \"@mui/material\";\n+import Button from \"@mui/material/Button\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\nExecution time: 0h:00m:7s sec\n```\n\n<Alert type=\"success\">\n  The build time is <u>30% faster</u> when not using a barrel file.<sup title=\"In a real-world scenario, the build time can decrease even more.\">*</sup>\n</Alert>\n\n**Fun fact:** [Next.js](https://nextjs.org/) implemented an `optimizePackageImports` option that skips barrel files and directly imports from the target, preventing loading unnecessary modules. The build times improvements [they declare](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js) vary from ~15% to ~70% time boost on the development builds (depending on the actual library). They also declare a ~28% improvement on production builds.\n\n## The test-time cost\n\nIn both articles (I highly recommend reading those):\n\n- [\"Why is My Jest Test Suite So Slow?\"](https://dev.to/twynsicle/why-is-my-jest-test-suite-so-slow-1od) by Steven Lemon, and\n- [\"Speeding up the JavaScript ecosystem - The barrel file debacle\"](https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7/) by Marvin Hagemeister\n\n...the conclusion is the same: barrel files slow down tests.\n\n> The problem is that Jest has no idea where the component we’re importing is located. The barrel file has intentionally obfuscated that fact. So when Jest hits a barrel file, it must load every export referenced inside it. This behavior quickly gets out of hand for large libraries like `@mui/material`. We’re looking for a single button and end up loading hundreds of additional files. – Steven Lemon in [\"Why is My Jest Test Suite So Slow?\"](https://dev.to/twynsicle/why-is-my-jest-test-suite-so-slow-1od)\n\nLet’s run the same test suite on two modules:\n\n- **Importing from barrel file:**\n\n```jsx\nimport { Button } from \"@mui/material\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\n> node scripts/test.js\n\n PASS  src/App.test.js\n  ✓ renders button (25 ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nTime:        1.717 s, estimated 2 s\n```\n\n- **Importing directly from the module:**\n\n```diff\n-import { Button } from \"@mui/material\";\n+import Button from \"@mui/material/Button\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\n> node scripts/test.js\n\n PASS  src/App.test.js\n  ✓ renders button (29 ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nTime:        1.097 s\n```\n\n<Alert type=\"success\">\n  The test duration <u>decreased from ~1.7 to ~1.1 seconds</u> when not importing from a barrel file.\n</Alert>\n\nNotice the test suite itself took 25-29ms. The 600ms overhead comes from building the module graph. The cost of loading modules can change depending on the machine and the tooling.\n\nIn my lab setup, 10 independent tests running in 4 child processes would result in a $$\\frac{0.6 \\times 10}{4} = 1.5$$ seconds overhead.\n\n## The lint-time cost\n\nBarrel files affect the linting performance. Let’s say you use the `import/no-cycle` rule from `eslint-plugin-import`, which ensures there is no resolvable path back to a module via its dependencies by building a dependency graph. When it comes across a barrel file, the linting time will take longer because it has to resolve all the exports from the barrel file.\n\n<Alert type=\"info\">\n  Unlike testing, linting is done on a file basis, so the dependency graph is built for each file separately.\n</Alert>\n\n## Developer experience\n\n1. Most (if not all) IDEs have autocomplete and IntelliSense - you can type the function name, and it will get the import right automatically.\n\n2. Having barrel files makes code navigation harder - <kbd>CMD + click</kbd> navigates to the barrel file instead of the actual definition of the module.\n\nAdditionally,\n\n- consistency is hard to enforce, as developers can still bypass the barrel, importing directly from individual files,\n- barrel files can cause circular dependencies, especially when modules within the same directory import from the barrel file instead of directly referencing the needed file.\n\n<Newsletter />\n\n## Conclusion\n\nAs software engineers, we are implementing new features daily, and each one has to be covered by _tests_. To do so, we use _linters_ to help us write better code faster. Then, we _build_ our app for a testing environment before releasing it to production (_another build_), and so on...\n\nBuilds, tests, and tooling will only get slower as the application grows. Avoiding barrel files can improve performance without compromising the architecture or the developer experience. Fortunately, there’s [an ESLint rule](https://github.com/gajus/eslint-plugin-canonical#no-barrel-import) to help you fight with barrel file imports.\n\n---\n\nAdditional resources worth checking:\n- [Jason Miller post on X about Barrel Files](https://x.com/_developit/status/1842225012092104732)\n- [Shu Ding post about how Next.js optimized packages imports](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js)\n","excerpt":"Barrel files consolidate the exports of multiple modules into a single file. We use them to import a module using a single import statement without…","tableOfContents":{"items":[{"url":"#the-bundle-size-cost","title":"The bundle size cost"},{"url":"#the-build-time-cost","title":"The build-time cost"},{"url":"#the-test-time-cost","title":"The test-time cost"},{"url":"#the-lint-time-cost","title":"The lint-time cost"},{"url":"#developer-experience","title":"Developer experience"},{"url":"#conclusion","title":"Conclusion"}]},"fields":{"slug":"/blog/pitfalls-of-barrel-files-in-javascript-modules/","timeToRead":{"minutes":5.985,"words":1197}},"frontmatter":{"title":"Why you should avoid Barrel Files in JavaScript Modules?","authors":["Bartosz Łaniewski"],"keywords":["JavaScript","Architecture"],"language":"en","description":null,"dateCreated":"March 27, 2024","dateCreatedMeta":"2024-03-28 00:00:00 +0100","dateUpdated":"April 05, 2024","dateUpdatedMeta":"2024-04-05 14:30:00 +0100","datePublished":"April 05, 2024","datePublishedMeta":"2024-04-05 14:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/pitfalls-of-barrel-files-in-javascript-modules/index.md"}},{"id":"f49d0a2d-3925-5ae5-8320-57422f8b715f","body":"\nWhen implementing applications, we often need to communicate with external services via APIs. In such cases, it’s crucial to ensure that the data received from these APIs is valid and conforms to the expected format. It’s essential for maintaining the integrity and functionality of various systems.\n\n## What is Zod\n\n[Zod](https://github.com/colinhacks/zod) is a TypeScript-first schema declaration and validation library. It provides an elegant and expressive syntax for defining data schemas and validating data against those schemas in the runtime. Here’s a simple example using TypeScript:\n\n```ts\nimport { z } from \"zod\";\n\nconst userSchema = z.object({\n  id: z.string().uuid(),\n  email: z.string().email(),\n  login: z.string(),\n  createdAt: z.string().datetime(),\n  deletedAt: z.string().datetime().nullable(),\n});\n\nconst userData = {\n  id: \"3f740a80-0af0-4976-9bad-db83b15c7bf7\",\n  email: \"jan.kowalski@example.com\",\n  login: \"jan.kowalski\",\n  createdAt: \"2020-01-01T00:00:00Z\",\n  deletedAt: null,\n};\n\ntry {\n  const validatedUser = userSchema.parse(userData);\n\n  console.log(validatedUser);\n} catch (error) {\n  console.error(error.errors);\n}\n```\n\nIn this example, `userSchema` defines a schema for user data, specifying the expected types and constraints for each field. The `parse` method is then used to validate the `userData` object against the schema. If validation fails, an error is thrown with details about the validation errors.\n\n## Why use Zod\n\n- **Type Safety:** Zod integrates seamlessly with TypeScript, providing strong type checking at compile-time. This helps to catch potential issues early in the development process.\n\n- **Error Reporting:** When validation fails in the run-time, Zod provides detailed error messages, including information about the specific fields that didn’t pass validation. This aids in diagnosing and fixing issues efficiently.\n\n- **Readability and Expressiveness:** Zod’s syntax is clean and expressive, making it easy to define and understand complex data structures. This enhances code readability and maintainability.\n\n- **Flexibility:** Zod allows you to create sophisticated validation rules, including custom validation functions, conditional validation, and more. This flexibility is valuable when dealing with diverse and evolving data structures.\n\n<Newsletter />\n\n## How to use Zod\n\nIn a real application, I’d encourage encapsulating the utilization of Zod within a generic helper function. Let’s examine a refined implementation:\n\n```ts\n// api/validator.ts\nimport { z, ZodIssue } from \"zod\";\n\ninterface ValidateConfig<T extends z.ZodTypeAny> {\n  dto: unknown;\n  schema: T;\n  schemaName: string;\n}\n\nexport function validateSchema<T extends z.ZodTypeAny>(\n  config: ValidateConfig<T>\n): z.infer<T> {\n  const { data, success, error } = config.schema.safeParse(config.dto);\n\n  if (success) {\n    return data;\n  } else {\n    captureError(`API Validation Error: ${config.schemaName}`, {\n      dto: config.dto,\n      error: error.message,\n      issues: error.issues,\n    });\n\n    throw error;\n  }\n}\n\nfunction captureError(message: string, extra = {}): void {\n  if (__DEV__) {\n    console.error(message, extra);\n  } else {\n    // TODO: report to Sentry/something else\n  }\n}\n```\n\nThis helper function takes a data transfer object (DTO), a Zod schema, and a schema name as arguments. It then validates the DTO against the schema and returns the validated data if validation succeeds. If validation fails, it logs an error message and throws an error.\n\nWith such a function ready, we only have to define a schema for each API response and use the helper function to validate the response data. Here’s an example of how that could look like:\n\n```ts\n// api/requests/v1/accountDetails/schema.ts\nimport { z } from \"zod\";\n\nexport const schema = z.object({\n  id: z.string().uuid(),\n  email: z.string().email(),\n  login: z.string(),\n  createdAt: z.string().datetime(),\n  deletedAt: z.string().datetime().nullable(),\n});\n```\n\n```ts\n// api/requests/v1/accountDetails/types.ts\nimport { z } from \"zod\";\nimport { schema } from \"./schema\";\n\nexport type AccountDetailsResponse = z.infer<typeof schema>;\nexport type AccountDetailsErrorResponse = Record<string, unknown>;\n```\n\n```ts {8-10}\n// api/requests/v1/accountDetails/request.ts\nimport { apiClient } from \"@/api/client\";\nimport { validateSchema } from \"@/api/validator\";\n\nimport { schema } from \"./schema\";\nimport { AccountDetailsResponse } from \"./types\";\n\nfunction validate(dto: unknown): AccountDetailsResponse {\n  return validateSchema({ dto, schema, schemaName: \"v1/account/details\" });\n}\n\nexport async function getAccountDetails(): Promise<AccountDetailsResponse> {\n  const response = await apiClient.get(\"/api/v1/account/details\");\n\n  return validate(response.data);\n}\n```\n\n## Conclusion\n\nAPI response validation is a critical aspect of building reliable and robust applications. Zod, with its TypeScript-first approach and expressive syntax, simplifies the process of defining and enforcing data schemas.\n\nBy incorporating Zod into your workflow, you can enhance the integrity of your APIs, catch potential issues early, and ensure that your application communicates seamlessly with external services.\n","excerpt":"When implementing applications, we often need to communicate with external services via APIs. In such cases, it’s crucial to ensure that the data received…","tableOfContents":{"items":[{"url":"#what-is-zod","title":"What is Zod"},{"url":"#why-use-zod","title":"Why use Zod"},{"url":"#how-to-use-zod","title":"How to use Zod"},{"url":"#conclusion","title":"Conclusion"}]},"fields":{"slug":"/blog/2023-11-19-api-response-validation-with-zod/","timeToRead":{"minutes":3.335,"words":667}},"frontmatter":{"title":"API Response validation with Zod","authors":["Bartosz Łaniewski"],"keywords":["JavaScript","TypeScript"],"language":"en","description":null,"dateCreated":"November 19, 2023","dateCreatedMeta":"2023-11-20 00:00:00 +0100","dateUpdated":"December 25, 2023","dateUpdatedMeta":"2023-12-26 00:00:00 +0100","datePublished":"November 19, 2023","datePublishedMeta":"2023-11-20 00:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/2023-11-19-api-response-validation-with-zod/index.md"}},{"id":"afb5b5a2-7917-5f76-bc42-4912cf350058","body":"\nMore than [240 000 repositories on GitHub](https://github.com/facebook/flow/network/dependents) use Flow, but only a few export Flow definitions. In this article, I’ll show you how to export Flow definitions for a module. Before starting, I encourage you to read my previous article about [publishing Tree Shaking-friendly packages to npm](/blog/2018-04-29-publishing-packages-to-npm/).\n\n## What is Flow?\n\nYou’ve probably already seen [Gary’s talk from CodeMash 2012](https://www.destroyallsoftware.com/talks/wat) about JavaScript. With Flow in your hands, there should be no more „_wat’s_”.\n\n> Flow is a static type checker for your JavaScript code. It does a lot of work to make you more productive. Making you code faster, smarter, more confidently, and to a bigger scale. – [Introduction to type checking with Flow](https://flow.org/en/docs/getting-started/)\n\nFlow was first presented at the [Scale Conference](https://atscaleconference.com/) in 2014 by Facebook. Its main goal was to add additional syntax to JavaScript language to prevent type errors and give developers a more concise idea about bugs that can occur in their code. It also offers a way for IDEs to provide a better environment for spotting errors in real-time.\n\n## How to export Flow definitions?\n\nThere are currently two ways to export Flow definitions. The easiest one is to include the source files within your package. All you have to do is change their extension to `.js.flow` and include them with the bundle.\n\n### Exporting Flow files\n\nLet’s start by installing the required npm dependencies using the following command:\n\n```bash\n$ npm install --save-dev glob fs-extra\n```\n\nOnce installed, we can write a script that will copy all source files to the `/dest` directory and change their extension to `.js.flow`:\n\n```javascript\n// ./scripts/copy-flow-definitions.js\nimport { basename, resolve } from \"path\";\nimport { copy } from \"fs-extra\";\nimport glob from \"glob\";\n\nasync function copyFile(file) {\n  const srcDir  = resolve(__dirname, \"../src\");\n  const destDir = resolve(__dirname, \"../dest\");\n  const fileDef = `${file}.flow`.replace(srcDir, destDir);\n\n  await copy(file, fileDef);\n\n  console.log(`Copied ${file} to ${fileDef}`);\n}\n\nglob(resolve(__dirname, \"../src/**/*.js\"), (err, files) => {\n  files.forEach(file => copyFile(file));\n});\n```\n\nThen, you can execute this script at the end of your build pipeline as follows:\n\n```json\n{\n  \"scripts\": {\n    \"build\": \"npx babel ./src -d ./dest\",\n    \"postbuild\": \"node ./scripts/copy-flow-definitions.js\"\n  }\n}\n```\n\n<Newsletter />\n\n### Adding definitions to flow-typed\n\nIf you plan to version your definitions, you should contribute to the `flow-typed` repository instead. Flow supports library definitions, which allow you to describe the interface of a module or library separately from the implementation of that module/library.\n\nYou can add your definitions by [contributing library definitions](https://flow-typed.github.io/flow-typed/#/?id=how-do-i-contribute-library-definitions) to the `flow-typed` repository. It will allow people who use your library to fetch definitions by using the following command:\n\n```bash\n$ flow-typed install library@x.x.x\n```\n\n## Conclusion\n\nIt is important to export Flow definitions so Flow can give errors if someone accidentally misuses your library. Additionally, it integrates well with most IDEs, giving developers a better experience by providing real-time documentation, auto-complete, and pointing mistakes.\n","excerpt":"More than 240 000 repositories on GitHub use Flow, but only a few export Flow definitions. In this article, I’ll show you how to export Flow definitions…","tableOfContents":{"items":[{"url":"#what-is-flow","title":"What is Flow?"},{"url":"#how-to-export-flow-definitions","title":"How to export Flow definitions?","items":[{"url":"#exporting-flow-files","title":"Exporting Flow files"},{"url":"#adding-definitions-to-flow-typed","title":"Adding definitions to flow-typed"}]},{"url":"#conclusion","title":"Conclusion"}]},"fields":{"slug":"/blog/2018-05-13-exporting-flow-definitions-to-npm/","timeToRead":{"minutes":2.365,"words":473}},"frontmatter":{"title":"How to export Flow definitions in npm packages?","authors":["Bartosz Łaniewski"],"keywords":["JavaScript","Flow","npm"],"language":"en","description":null,"dateCreated":"May 12, 2018","dateCreatedMeta":"2018-05-13 00:00:00 +0100","dateUpdated":"April 07, 2024","dateUpdatedMeta":"2024-04-07 11:00:00 +0100","datePublished":"May 12, 2018","datePublishedMeta":"2018-05-13 00:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/2018-05-13-exporting-flow-definitions-to-npm/index.md"}},{"id":"6198e53d-3784-5a9e-8e80-e40f4f623c58","body":"\nWith the rise of ES2015, modules have officially become an integral part of JavaScript. By their nature, ES2015 modules are static and can be optimized at the compile time. Various tools and techniques have been created to minimize the total size of generated bundles. The one described in this article is called tree shaking.\n\n## Introduction to npm packages\n\n**npm** is the most popular package manager for JavaScript. It is shipped by default with Node.js – the JavaScript runtime environment. Each month, there are over [20 billion downloads](https://www.npmjs.com/) from the npm registry, which counts more than half a million different packages.\n\n### How does bundling work?\n\nA package is a directory described by a `package.json`. Each package is composed of one or more modules that can be loaded by Node.js’ `require()`. A package usually exposes a single module via the `main` field specified in `package.json`. If there’s no such field, npm will look for `index.js` in the root directory.\n\n\nMost bundlers (such as [Webpack](https://webpack.js.org/) or [Browserify](https://browserify.org/)) will output a unique JavaScript file when building the package. For example, let’s consider the following code:\n\n```javascript\n// Entry point: index.js\nexport * as moduleA from \"./src/moduleA\";\nexport * as moduleB from \"./src/moduleB\";\nexport * as moduleC from \"./src/moduleC\";\n```\n\nWebpack will start by compiling the source file (called _entry point_). It will then move from `import` to `import` and include every required file in the build pipe. It will generate a single bundle containing all the imported modules as follows:\n\n```javascript\n(function (modules) {\n  // Webpack stuff\n})({\n  \"./index.js\": function (module, exports, __webpack_require__) {\n    \"use strict\";\n    // Compiled entry-point\n  },\n  \"./src/moduleA.js\": function (module, exports, __webpack_require__) {\n    \"use strict\";\n    // Compiled moduleA\n  },\n  \"./src/moduleB.js\": function (module, exports, __webpack_require__) {\n    \"use strict\";\n    // Compiled moduleB\n  },\n  \"./src/moduleC.js\": function (module, exports, __webpack_require__) {\n    \"use strict\";\n    // Compiled moduleC\n  },\n});\n```\n\nOnce published to npm, each module can be loaded using Node.js’ `require()` (or [ES2015 `import`](https://tc39.es/ecma262/#sec-imports)) as follows:\n\n```javascript\nimport { moduleA, moduleB, moduleC } from \"package\";\n\nmoduleA.method();\nmoduleB.method();\nmoduleC.method();\n```\n\nSuch bundlers can work because [ES2015 packages are static by nature][1]: you can predict which modules are being imported and exported just by analyzing the code without the need to execute it. However, this has some drawbacks:\n\n- **conditional imports and exports** are unsupported – you have to declare your imports at the top level;\n- both imports and exports **cannot have any dynamic parts** – you cannot use string concatenation in `require()`.\n\n### What is tree shaking?\n\nTree shaking is a script that performs code analysis for a given bundle and checks which modules are never used at the **compile (build) time**. Let’s take the previous example:\n\n```javascript\nimport { moduleA, moduleB } from \"package\";\n```\n\n`package` exports `moduleA`, `moduleB`, and `moduleC`, but only the first two are imported. Without tree shaking, the final bundle would contain unreachable code (`moduleC`). Unused exports can be removed during bundling, potentially resulting in significant space savings.\n\n> Utilizing the tree shaking and dead code elimination can significantly reduce the code size we have in our application. The less code we send over the wire the more performant the application will be. – [Alex Bachuk](https://medium.com/@netxm/what-is-tree-shaking-de7c6be5cadd).\n\n<Newsletter />\n\n## Creating tree shaking-friendly packages\n\nOur goal will be to expose multiple module bundles from a single package so one can `import` only necessary parts instead of the entire library:\n\n```javascript\nimport * as moduleA from \"package/moduleA\";\nimport * as moduleB from \"package/moduleB\";\nimport { funcA, funcB } from \"package/moduleC\";\n```\n\n- If we import only `moduleA`, the two other modules will not be included in the final bundle because they aren’t required anywhere.\n- If we import only a specific function from a module (ex. `funcA`), the rest of the module’s content will be ignored.\n\nWe don’t have to access a named export like in previous examples. That means we don’t have to do a slow, dynamic property lookup. In our case, we know the content and can optimize the access.\n\n### Directory structure overview\n\n```\n├── scripts/\n│   └── copy.js\n├── package/\n│   └── package.json\n├── source/\n│   ├── moduleA/\n│   ├── moduleB/\n│   ├── moduleC/\n│   └── index.js\n└── package.json\n```\n\n- `scripts/` will contain all JavaScript binaries that will be used to build your package.\n- `package/` directory is where your package will reside once it is compiled. It is the directory that will be pushed to the npm registry.\n- `source/` directory is where your package source resides. It will not be pushed to the npm registry but should be in the repository.\n\nAs you can see, there are two `package.json` files. The one at the root will be used to declare your dependencies, metadata, and scripts. The second one will be pushed to the npm registry. It will get generated automatically and populated with more fields, such as `main`.\n\n### Compiling and building the package\n\nIn this article, we will use [Babel](https://babeljs.io/) for the compilation process. Babel is a JavaScript transpiler that converts ECMAScript and other JavaScript subsets into plain JavaScript that can be used in any environment. First, you need to install Babel as a development dependency in your project:\n\n```bash\n$ npm install --save-dev babel-cli\n```\n\nFor in-depth installation details, I encourage you to check [Babel’ setup section in their documentation](https://babeljs.io/setup/). Once Babel is installed, we can define a few scripts in `/package.json`:\n\n```json\n{\n  \"private\": true,\n  \"dependencies\": {\n    \"rimraf\": \"^5.0.5\",\n    \"fs-extra\": \"^11.2.0\"\n  },\n  \"scripts\": {\n    \"clean\": \"npx rimraf ./package/*\",\n    \"build\": \"npx babel ./source --out-dir ./package\",\n    \"copy\": \"npx babel-node ./scripts/copy.js\"\n  }\n}\n```\n\n- `npm run clean` will remove built modules from the `/package` directory.\n- `npm run build` will build modules and pipe the bundles to the `/package` directory.\n- `npm run copy` will execute the `/scripts/copy.js` script described in the next section.\n\n<Alert type=\"info\">\n  It is important to set `private` to `true` in `/package.json` to prevent you from accidentally pushing your entire repository to the npm registry instead of only the build.\n</Alert>\n\n### Copying required files into the package\n\nThe script below will copy meta files such as `README.md` and `LICENSE` to your final package. Additionally, it will create a brand new `package.json`.\n\n```javascript\n// File: /scripts/copy.js\nimport { basename, resolve } from \"path\";\nimport { copy, writeFile } from \"fs-extra\";\n\nasync function copyFile(file) {\n  const fileName = basename(file);\n  const filePath = resolve(__dirname, \"../package/\", fileName);\n\n  await copy(file, filePath);\n\n  console.log(`Copied ${file} to ${filePath}`);\n}\n\nasync function createPackageFile() {\n  const oldPackagePath = resolve(__dirname, \"../package.json\");\n  const oldPackageData = require(oldPackagePath);\n\n  delete oldPackageData.private;\n  delete oldPackageData.scripts;\n  delete oldPackageData.devDependencies;\n\n  const newPackagePath = resolve(__dirname, \"../package/package.json\");\n  const newPackageData = Object.assign(oldPackageData, { main: \"./index.js\" });\n  await writeFile(newPackagePath, JSON.stringify(newPackageData), \"utf8\");\n\n  console.log(`Created package.json in ${newPackagePath}`);\n}\n\nasync function run() {\n  await copyFile(\"README.md\");\n  await copyFile(\"LICENSE\");\n  await createPackageFile();\n}\n\nrun();\n```\n\n## Limitations and solutions\n\nTree shaking is a relatively new technology and still has some limitations. While not every single one can be resolved directly in tree shaking, there are various ways around these problems.\n\n### Side effects in module bundles\n\nSome modules have side effects: they can perform additional tasks, such as modifying global variables instead of just exporting their content. According to the ECMAScript specifications, all child modules must be evaluated because they could contain side effects. Let’s take the following examples:\n\n```javascript\n// moduleA\nconsole.log(\"Side effect\");\n\nexport {/* … */};\nexport default /* … */;\n```\n\n```javascript\n// moduleB\nwindow.a = /* … */;\nwindow.b = /* … */;\nwindow.c = /* … */;\n```\n\nBecause of this potential behavior, tree shaking cannot remove all unreachable code. However, some bundlers, such as Webpack, drop the responsibility on the developers by providing a `sideEffect` option. By setting this flag to `false`, you indicate that your package is a _pure module_ and doesn’t have any side effects. Therefore, it can be aggressively optimized.\n\n### Wrong specs implementation\n\n> Current tooling differs on the correct way to handle default imports/exports. Avoiding them all together can help avoid tooling bugs and conflicts. – [TSLint rules][6]\n\n### Class-based tree shaking\n\nClass-based tree shaking is currently not supported because of the dynamic nature of JavaScript’s property accessors – they cannot be statically determined, especially when using bracket notation. Let’s consider the following example:\n\n```javascript\nconst bar = new Foo();\n\nbar.methodA();\nbar[\"methodB\"]();\nbar[`method${n}`]();\nbar[\"methodD\".split(\"\").reverse().join(\"\")]();\n```\n\nAs you can see, `methodA` and `methodB` can be statically determined as being used at compile time, but this is not true for the last two cases. There are different proposals to improve tree shaking in classes.\n\n#### Bind operator proposal\n\n> The :: operator creates a bound function such that the left hand side of the operator is bound as the this variable to the target function on the right hand side. By providing syntactic sugar for these use cases we will enable a new class of \"virtual method\" library, which will have usability advantages over the standard adapter patterns in use today. – [tc39/proposal-bind-operator][2]\n\n```javascript\nimport Foo, { methodA, methodB } from \"foo\";\n\nconst bar = new Foo();\nbar::methodA();\nbar::methodB();\n```\n\n#### Pipeline operator proposal\n\n> This proposal introduces a new operator \\|\\> similar to _F#, OCaml, …, Hack and LiveScript_, as well as UNIX pipes. It’s a backwards-compatible way of streamlining chained function calls in a readable, functional manner, and provides a practical alternative to extending built-in prototypes. – [tc39/proposal-pipeline-operator][3]\n\n```javascript\nimport Foo, { methodA, methodB } from \"foo\";\n\nconst bar = new Foo();\nbar |> methodA();\nbar |> methodB();\n```\n\n## Resources\n\n1. [Exploring JS – Static module structure][1]\n2. [ECMAScript – This-Binding Syntax][2]\n3. [ECMAScript – The Pipeline Operator][3]\n4. [Rollup – Tree shaking documentation][4]\n5. [Webpack – Tree shaking documentation][7]\n6. [Rollup vs Webpack2 – David Rodenas][5]\n\n[1]: https://exploringjs.com/es6/ch_modules.html#static-module-structure \"Exploring JS – Static module structure\"\n[2]: https://github.com/tc39/proposal-bind-operator \"ECMAScript This-Binding Syntax\"\n[3]: https://github.com/tc39/proposal-pipeline-operator \"ESNext Proposal: The Pipeline Operator\"\n[4]: https://rollupjs.org/guide/en#tree-shaking \"Rollup – Tree shaking documentation\"\n[5]: https://web.archive.org/web/20190922121239/http://david-rodenas.com:80/posts/rollup-vs-webpack-and-tree-shaking \"Rollup vs. Webpack – Tree shaking\"\n[6]: https://palantir.github.io/tslint/rules/no-default-export/ \"TSLint rules – no default export\"\n[7]: https://webpack.js.org/guides/tree-shaking/ \"Webpack – Tree shaking documentation\"\n","excerpt":"With the rise of ES2015, modules have officially become an integral part of JavaScript. By their nature, ES2015 modules are static and can be optimized at…","tableOfContents":{"items":[{"url":"#introduction-to-npm-packages","title":"Introduction to npm packages","items":[{"url":"#how-does-bundling-work","title":"How does bundling work?"},{"url":"#what-is-tree-shaking","title":"What is tree shaking?"}]},{"url":"#creating-tree-shaking-friendly-packages","title":"Creating tree shaking-friendly packages","items":[{"url":"#directory-structure-overview","title":"Directory structure overview"},{"url":"#compiling-and-building-the-package","title":"Compiling and building the package"},{"url":"#copying-required-files-into-the-package","title":"Copying required files into the package"}]},{"url":"#limitations-and-solutions","title":"Limitations and solutions","items":[{"url":"#side-effects-in-module-bundles","title":"Side effects in module bundles"},{"url":"#wrong-specs-implementation","title":"Wrong specs implementation"},{"url":"#class-based-tree-shaking","title":"Class-based tree shaking"}]},{"url":"#resources","title":"Resources"}]},"fields":{"slug":"/blog/2018-04-29-publishing-packages-to-npm/","timeToRead":{"minutes":8.225,"words":1645}},"frontmatter":{"title":"How to publish a Tree Shaking friendly npm package?","authors":["Bartosz Łaniewski"],"keywords":["JavaScript","npm"],"language":"en","description":null,"dateCreated":"April 28, 2018","dateCreatedMeta":"2018-04-29 00:00:00 +0100","dateUpdated":"April 06, 2024","dateUpdatedMeta":"2024-04-07 00:00:00 +0100","datePublished":"April 28, 2018","datePublishedMeta":"2018-04-29 00:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/2018-04-29-publishing-packages-to-npm/index.md"}}]}},"staticQueryHashes":["1271460761","3216310583","991007626"],"slicesMap":{}}