{"componentChunkName":"component---src-templates-blog-posts-tsx","path":"/posts/seo/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://laniewski.me"}}},"pageContext":{"keyword":"SEO","data":[{"id":"e3c6f8f5-1fe5-5588-8f80-d262181f4e77","body":"\nAs a software engineer, I love to automate things. I also love to write blog posts. So I decided to automate the process of generating thumbnails for my Gatsby blog to improve my brand consistency and recognition across social media platforms. In this article, I will show you how to do it.\n\n## Why are thumbnails important?\n\n1. **First Impression Matter**\n\nBlog post thumbnails act as the visual ambassadors of your content, offering a sneak peek into the article. A compelling thumbnail serves as the initial point of contact between your content and potential readers, making it a low-hanging fruit determining whether users will click through or scroll past.\n\n2. **Social Media Optimization**\n\nBlog post thumbnails are important in optimizing content for platforms like Facebook, Twitter, and Instagram. Social media users often scroll through feeds rapidly, and a striking thumbnail can make your content stand out. It acts as a visual anchor, inviting users to pause and delve deeper into your blog.\n\n3. **Increased Click-Through Rates**\n\nA well-crafted thumbnail can significantly boost click-through rates. When users are presented with a visually appealing and relevant image, they are more likely to be enticed into exploring the full article. This not only enhances the visibility of your content but also contributes to the overall success of your blog by increasing engagement metrics.\n\n## Step 1: Prepare HTML image template\n\nOur thumbnails will be created based on a parametrized HTML template. We will then use a library to convert the HTML to an image. The template should contribute to brand consistency and recognition. Here’s a basic template you can use as a starting point:\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style>\n      :root {\n        --imgWidth: {{imgWidth}};\n        --imgHeight: {{imgHeight}};\n      }\n\n      html, body {\n        margin: 0;\n      }\n\n      body {\n        width: var(--imgWidth);\n        height: var(--imgHeight);\n      }\n    </style>\n  </head>\n  <body>\n    <p class=\"title\">{{title}}</p>\n    <p class=\"domain\">{{link}}</p>\n  </body>\n</html>\n```\n\n<Alert type=\"info\">\n  `{{title}}`, `{{link}}`, `{{imgWidth}}`, and `{{imgHeight}}` are variables that will be replaced during the image generation phase.\n</Alert>\n\n## Step 2: Create a function to generate thumbnails\n\nThere are plenty of libraries that can be used to convert HTML to an image. I decided to use [`node-html-to-image`](https://www.npmjs.com/package/node-html-to-image) as it provides a simple, easy-to-use API. It also allows us to generate multiple images in one call, which benefits performance.\n\nTo get started, install the library using the following command:\n\n```bash\n$ npm install node-html-to-image\n```\n\nNext, let’s create a function that will accept a list of blog posts and generate thumbnails for each of them:\n\n```js\nimport nodeHtmlToImage from \"node-html-to-image\";\n\nconst html = `<YOUR_HTML_TEMPLATE>`;\n\nfunction mapSlugToImageName(slug) {\n  return slug\n    .replace(/\\/$/, \"\") // Remove trailing slash\n    .replace(\"/\", \"-\"); // Replace slashes with dashes\n}\n\nfunction buildOutputPath(slug) {\n  return `./static/thumbnails/${mapSlugToImageName(slug)}.png`;\n}\n\nfunction buildLinkPath(slug) {\n  return `https://example.com${slug}`;\n}\n\nexport async function createBlogPostThumbnails(posts) {\n  return nodeHtmlToImage({\n    html,\n    content: posts.map((post) => ({\n      output: buildOutputPath(post.slug),\n      // Parameters to be passed to the template:\n      link: buildLinkPath(post.slug),\n      title: post.title,\n      imgWidth: 1600,\n      imgHeight: 900,\n    })),\n  });\n}\n```\n\n<Newsletter />\n\n## Step 3: Create thumbnails when building pages\n\nThe function will be called in the `gatsby-node.js` file, in the `createPages` hook. First, we need to fetch a list of all blog posts. Then, we can call the `createBlogPostThumbnails` function with the data. The function will return a promise that will resolve once all thumbnails are generated.\n\n```js\nexport const createPages = async ({ graphql }) => {\n  const allPostsResult = await graphql(`\n    query AllPostsQuery {\n      allMdx {\n        nodes {\n          frontmatter {\n            title\n          }\n          fields {\n            slug\n          }\n        }\n      }\n    }\n  `);\n\n  await createBlogPostThumbnails(\n    allPostsResult.allMdx.nodes.map((post) => ({\n      title: post.frontmatter.title,\n      slug: post.fields.slug,\n    })),\n  );\n};\n```\n\n## Step 4: Use images in your SEO component\n\nIf you followed my last article [about creating an SEO component for Gatsby](/blog/ultimate-gatsby-seo-guide/how-to-create-an-seo-component/), you can now use the generated thumbnails for social sharing cards. We simply have to generate a link to the image and pass it to the `image` property of the `SEO` component. Here’s a rough idea of how it could look like:\n\n```tsx\nexport function Head({ data, location }: HeadProps<DataType, PageContextType>) {\n  const slug = location.pathname;\n  const siteUrl = data.site.siteMetadata.siteUrl;\n  const thumbnailUrl = `${siteUrl}/thumbnails/${mapSlugToImageName(slug)}.png`;\n\n  return <SEO {/* other props */} image={thumbnailUrl} />;\n}\n\nexport const query = graphql`\n  {\n    site {\n      siteMetadata {\n        siteUrl\n      }\n    }\n  }\n`;\n```\n\n## Conclusion\n\nIn a world where information competes for attention, blog post thumbnails are a powerful tool in every content creator’s arsenal. By automating thumbnail generation, you can save time and effort and focus on what’s important – creating great content.\n","excerpt":"As a software engineer, I love to automate things. I also love to write blog posts. So I decided to automate the process of generating thumbnails for my…","tableOfContents":{"items":[{"url":"#why-are-thumbnails-important","title":"Why are thumbnails important?"},{"url":"#step-1-prepare-html-image-template","title":"Step 1: Prepare HTML image template"},{"url":"#step-2-create-a-function-to-generate-thumbnails","title":"Step 2: Create a function to generate thumbnails"},{"url":"#step-3-create-thumbnails-when-building-pages","title":"Step 3: Create thumbnails when building pages"},{"url":"#step-4-use-images-in-your-seo-component","title":"Step 4: Use images in your SEO component"},{"url":"#conclusion","title":"Conclusion"}]},"fields":{"slug":"/blog/ultimate-gatsby-seo-guide/how-to-automatically-generate-thumbnails/","timeToRead":{"minutes":3.72,"words":744}},"frontmatter":{"title":"Ultimate Gatsby SEO Guide: How to generate thumbnails?","authors":["Bartosz Łaniewski"],"keywords":["Gatsby","SEO"],"language":"en","description":null,"dateCreated":"December 16, 2023","dateCreatedMeta":"2023-12-16 13:10:00 +0100","dateUpdated":"December 25, 2023","dateUpdatedMeta":"2023-12-26 00:00:00 +0100","datePublished":"December 16, 2023","datePublishedMeta":"2023-12-16 16:45:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/ultimate-gatsby-seo-guide/how-to-automatically-generate-thumbnails.md"}},{"id":"bdc34da5-64ce-5d46-a072-95239ffc5c0a","body":"\nOne way to enhance your Gatsby site’s SEO capabilities is by creating a custom SEO component for easy metadata tag management. In this blog post, we’ll explore the Head API and a step-by-step guide on creating a Gatsby SEO component.\n\n## What is the Gatsby Head API?\n\n[Gatsby Head API](https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-head/) simplifies the process of managing the [document head](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head), where metadata such as title tags, meta descriptions, and other elements crucial for SEO are defined.\n\nTo use the Head API, you simply have to export a named function called `Head` from your pages (and templates used in `createPage`), as follows:\n\n```tsx\nexport function Head(props: HeadProps<DataType, PageContextType>) {\n  return (\n    <>\n      <title>…</title>\n      <meta name=\"keywords\" content=\"…\" />\n      <meta name=\"description\" content=\"…\" />\n    </>\n  );\n}\n```\n\nYou can read more about the Gatsby Head API in the official documentation [here](https://www.gatsbyjs.com/docs/reference/built-in-components/gatsby-head/).\n\n## Step 1: Create a basic SEO component\n\nLet’s start by creating a new `components/SEO.tsx` component that will set basic metadata information in the document head:\n\n```tsx\ninterface SEOProps {\n  title: string;\n  description: string;\n}\n\nexport function SEO({ title, description }: React.PropsWithChildren<SEOProps>) {\n  return (\n    <>\n      <title>{title}</title>\n      <meta name=\"description\" content={description} />\n\n      {children}\n    </>\n  );\n};\n```\n\nOur basic component accepts 3 properties:\n- `title`: the title of the page;\n- `description`: the description of the page;\n- `children`: any additional elements that should be included in the document head;\n\nWe can now use the component inside pages and templates, as follows:\n\n```tsx\nexport function Head() {\n  return (\n    <SEO title=\"Page title\" description=\"Page description\">\n      <html lang=\"en\" />\n    </SEO>\n  );\n}\n```\n\n<Newsletter />\n\n## Step 2: Add canonical links\n\nA canonical tag defines the main version for duplicate and similar pages. It tells search engines which version of a page they should index and rank (for example, to use https://example.com instead of https://www.example.com). To add canonical links, you can use the official Gatsby plugin called [`gatsby-plugin-canonical-urls`](https://www.gatsbyjs.com/plugins/gatsby-plugin-canonical-urls/). It works well for most cases.\n\nFor a more customizable approach, we can leverage the Head API and the `location` property to create custom canonical links. Let’s start by extending our SEO component with a `url` property:\n\n```tsx {4,10,18}\nimport { useStaticQuery, graphql } from \"gatsby\";\n\ninterface SEOProps {\n  url: string;\n  title: string;\n  description: string;\n}\n\nexport function SEO({\n  url,\n  title,\n  description,\n  children,\n}: React.PropsWithChildren<SEOProps>) {\n  return (\n    <>\n      <title>{title}</title>\n      <link rel=\"canonical\" href={url} />\n      <meta name=\"description\" content={description} />\n\n      {children}\n    </>\n  );\n}\n```\n\nThen, we can populate the `url` property in our pages and templates, as follows:\n\n```tsx\ninterface DataType {\n  site: {\n    siteMetadata: {\n      siteUrl: string;\n    };\n  };\n};\n\nexport function Head({ data, location }: HeadProps<DataType>) {\n  const siteUrl = data.site.siteMetadata.siteUrl;\n  const slug = location.pathname;\n\n  return (\n    <SEO\n      url={`${siteUrl}${slug}`}\n      title=\"Page title\"\n      description=\"Page description\"\n    />\n  );\n}\n\nexport const query = graphql`\n  {\n    site {\n      siteMetadata {\n        siteUrl\n      }\n    }\n  }\n`;\n```\n\n## Step 3: Add social sharing cards\n\nOpen Graph (OG) tags instruct social networks like Facebook, Pinterest, LinkedIn, and other platforms what information to display whenever a URL to your page is shared. The four required Open Graph tags for every page are:\n- `og:title`,\n- `og:type`,\n- `og:image`,\n- `og:url`.\n\nTwitter provides its variants of those tags. Basic Twitter cards include:\n- `twitter:card`,\n- `twitter:site`,\n- `twitter:title`,\n- `twitter:description`,\n- `twitter:image`.\n\nAccording to [Twitter Documentation](https://developer.twitter.com/en/docs/twitter-for-websites/cards/guides/getting-started), if some of these tags are missing, Twitter will pull data from relevant Open Graph tags.\n\n<Alert type=\"warning\">\n  Make sure the URL specified in `og:url` matches the URL of the canonical page unless you have a specific intent.\n</Alert>\n\n```tsx {7,14,17-25,27,35-42}\nimport { useStaticQuery, graphql } from \"gatsby\";\n\ninterface SEOProps {\n  url: string;\n  title: string;\n  description: string;\n  image?: string;\n}\n\nexport function SEO({\n  url,\n  title,\n  description,\n  image,\n  children,\n}: React.PropsWithChildren<SEOProps>) {\n  const { site } = useStaticQuery(graphql`\n    query {\n      site {\n        siteMetadata {\n          siteUrl\n        }\n      }\n    }\n  `);\n\n  const metaImage = image || `${site.siteMetadata.siteUrl}/thumbnail.png`;\n\n  return (\n    <>\n      <title>{title}</title>\n      <link rel=\"canonical\" href={url} />\n      <meta name=\"description\" content={description} />\n\n      <meta name=\"og:url\" content={url} />\n      <meta name=\"og:type\" content=\"website\" />\n      <meta name=\"og:image\" content={metaImage} />\n      <meta name=\"og:title\" content={title} />\n      <meta name=\"og:description\" content={description} />\n      <meta name=\"twitter:card\" content=\"summary_large_image\" />\n      <meta name=\"twitter:title\" content={title} />\n      <meta name=\"twitter:creator\" content=\"@yourTwitterHandle\" />\n\n      {children}\n    </>\n  );\n}\n```\n\nUnfortunately, you cannot test Open Graph and Twitter cards locally, you need to deploy your changes so they are publicly accessible. Once deployed, you can post a link to your website in the [Facebook Debugger](https://developers.facebook.com/tools/debug) and Tweet Composer (in the Twitter client itself) to check that your cards render as expected.\n\n## Conclusion\n\nCreating a custom SEO component with Gatsby and the Head API is a straightforward process that significantly enhances your website’s search engine visibility. Managing metadata efficiently will empower you to create well-optimized pages that stand out in search engine rankings, ultimately driving more traffic to your website.\n","excerpt":"One way to enhance your Gatsby site’s SEO capabilities is by creating a custom SEO component for easy metadata tag management. In this blog post, we’ll…","tableOfContents":{"items":[{"url":"#what-is-the-gatsby-head-api","title":"What is the Gatsby Head API?"},{"url":"#step-1-create-a-basic-seo-component","title":"Step 1: Create a basic SEO component"},{"url":"#step-2-add-canonical-links","title":"Step 2: Add canonical links"},{"url":"#step-3-add-social-sharing-cards","title":"Step 3: Add social sharing cards"},{"url":"#conclusion","title":"Conclusion"}]},"fields":{"slug":"/blog/ultimate-gatsby-seo-guide/how-to-create-an-seo-component/","timeToRead":{"minutes":3.915,"words":783}},"frontmatter":{"title":"Ultimate Gatsby SEO Guide: How to create an SEO component?","authors":["Bartosz Łaniewski"],"keywords":["Gatsby","SEO"],"language":"en","description":null,"dateCreated":"December 15, 2023","dateCreatedMeta":"2023-12-15 18:10:00 +0100","dateUpdated":"December 25, 2023","dateUpdatedMeta":"2023-12-26 00:00:00 +0100","datePublished":"December 15, 2023","datePublishedMeta":"2023-12-15 18:10:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/ultimate-gatsby-seo-guide/how-to-create-an-seo-component.md"}},{"id":"35de612c-7f7a-55a1-a367-17364698e251","body":"\nCreating a sitemap is an essential step towards enhancing the visibility and SEO performance of your Gatsby website. A sitemap assists search engines in efficiently crawling and indexing your content. In this guide, I’ll walk you through the process of creating a sitemap for your Gatsby project, boosting its search engine optimization.\n\n## The Importance of a Sitemap\n\nA sitemap serves as a guide for search engines, helping them discover and rank your content more effectively. It also ensures that any updates or new pages are recognized. This is crucial for Search Engine Optimization (_SEO_) and ensuring that your website appears in Search Engine Results Pages (_SERPs_).\n\n## Step 1: Install the Gatsby Plugin\n\nGatsby simplifies the process of creating a sitemap by providing an official, dedicated plugin – [`gatsby-plugin-sitemap`](https://www.gatsbyjs.com/plugins/gatsby-plugin-sitemap/). To get started, open your Gatsby project and install the plugin using the following command:\n\n```bash\n$ npm install gatsby-plugin-sitemap\n```\n\nNext, integrate the plugin into your `gatsby-config.js` file:\n\n```javascript\nmodule.exports = {\n  siteMetadata: {\n    siteUrl: \"https://www.example.com\",\n  },\n  plugins: [\n    {\n      resolve: \"gatsby-plugin-sitemap\",\n    },\n  ],\n}\n```\n\nThis step automatically generates a `sitemap-index.xml` file in the root of your Gatsby project and, for every 45000 URLs a new `sitemap-n.xml` file containing all the basic information for search engines:\n\n```xml\n<!-- sitemap-index.xml -->\n<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <sitemap>\n    <loc>https://example.com/sitemap-0.xml</loc>\n  </sitemap>\n</sitemapindex>\n```\n\n```xml\n<!-- sitemap-0.xml -->\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">\n  <url>\n    <loc>https://example.com/blog/some-post-slug/</loc>\n    <changefreq>daily</changefreq>\n    <priority>0.7</priority>\n  </url>\n  <url>\n    <loc>https://example.com/blog/</loc>\n    <changefreq>daily</changefreq>\n    <priority>0.7</priority>\n  </url>\n  <url>\n    <loc>https://example.com/</loc>\n    <changefreq>daily</changefreq>\n    <priority>0.7</priority>\n  </url>\n</urlset>\n```\n\n## Step 2: Customize Your Sitemap\n\nWhile the default configuration works well, you may want to customize your sitemap to provide more information. Gatsby allows you to tailor the sitemap by [providing options](https://www.gatsbyjs.com/plugins/gatsby-plugin-sitemap/) in the `gatsby-config.js` file, as follows:\n\n```javascript\nmodule.exports = {\n  plugins: [\n    {\n      resolve: \"gatsby-plugin-sitemap\",\n      options: {\n        query: `\n          {\n            site {\n              siteMetadata {\n                siteUrl\n              }\n            }\n            allSitePage {\n              nodes {\n                path\n              }\n            }\n            allMdx {\n              nodes {\n                fields {\n                  slug\n                }\n                frontmatter {\n                  dateUpdated\n                }\n              }\n            }\n          }\n        `,\n        resolvePages: ({\n          allSitePage: { nodes: allSitePages },\n          allMdx: { nodes: allMdxNodes },\n        }) => {\n          const blogPostsPages = allMdxNodes.reduce(\n            (acc, node) => ({\n              ...acc,\n              [node.fields.slug]: node.frontmatter,\n            }),\n            {},\n          );\n\n          return allSitePages.map((page) => ({\n            ...page,\n            ...blogPostsPages[page.path],\n          }));\n        },\n        serialize: ({ path, dateUpdated }) => {\n          if (dateUpdated) {\n            return {\n              url: path,\n              lastmod: dateUpdated,\n              priority: 0.7,\n              changefreq: \"daily\",\n            };\n          } else {\n            return {\n              url: path,\n              priority: 0.5,\n              changefreq: \"daily\",\n            };\n          }\n        },\n      },\n    },\n  ],\n}\n```\n\nWith the configuration above, the new sitemap should contain the new field `<lastmod>` when the last update date is available for a given page:\n\n```xml\n<!-- sitemap-0.xml -->\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">\n  <url>\n    <loc>https://example.com/blog/some-post-slug/</loc>\n    <lastmod>2023-01-01T00:00:00.000Z</lastmod>\n    <changefreq>daily</changefreq>\n    <priority>0.7</priority>\n  </url>\n  <url>\n    <loc>https://example.com/blog/</loc>\n    <changefreq>daily</changefreq>\n    <priority>0.5</priority>\n  </url>\n  <url>\n    <loc>https://example.com/</loc>\n    <changefreq>daily</changefreq>\n    <priority>0.5</priority>\n  </url>\n</urlset>\n```\n\n<Alert type=\"info\">\n  **Crawlers interpret the sitemap differently.** For instance, [Google ignores `<priority>` and `<changefreq>` values](https://developers.google.com/search/docs/crawling-indexing/sitemaps/build-sitemap?hl=en&visit_id=638379916569097492-3578546875&rd=1#additional-notes-about-xml-sitemaps), but recommends adding a `<lastmod>` value to indicate the last update date for a given page.\n</Alert>\n\n## Step 3: Update your robots.txt file\n\nThe `robots.txt` file is a text file placed in a website’s root directory to instruct web crawlers about which parts of the site should not be crawled or indexed. The `Sitemap` directive in the `robots.txt` file is used to indicate the location of the XML sitemap.\n\nTo generate a `robots.txt` file, you can use the [`gatsby-plugin-robots-txt`](https://www.gatsbyjs.com/plugins/gatsby-plugin-robots-txt/) plugin. For our use case, we won’t overengineer the configuration. Let’s manually create a `robots.txt` file in the `static` folder and simply add a reference to the sitemap file to allow all crawlers to index our website:\n\n```txt\nSitemap: https://example.com/sitemap-index.xml\nUser-agent: *\nDisallow:\n```\n\n<Newsletter />\n\n## Step 4: Test and Deploy\n\nBefore deploying your Gatsby website with the new sitemap, it’s crucial to test it locally. The sitemap is only generated for production mode. To test your sitemap, you should run the following command:\n\n```bash\n$ gatsby build && gatsby serve.\n```\n\n…and head to `localhost:9000/sitemap-index.xml` to see the generated sitemap. Once you’ve confirmed that everything is working as expected, deploy your Gatsby website to your hosting provider.\n\n## Step 5: Submit to search engines\n\nThe next step is to submit it to major search engines. Google Search Console, Bing Webmaster Tools, and other search engine platforms provide tools for submitting and monitoring your sitemap.\n\n### How to submit a sitemap to Google Search Console\n\n1. Sign in to [Google Search Console](https://search.google.com/search-console) and select your website;\n2. In the navigation menu, in the **Indexing** section, click on **Sitemaps**;\n3. Enter a full sitemap URL in the **Add a new sitemap** field and click **Submit**.\n\n### How to submit a sitemap to Bing Webmaster Tools\n\n1. Sign in to [Bing Webmaster Tools](https://www.bing.com/webmasters/about) and select your website.\n2. In the navigation menu, click on **Sitemaps**, then click on **Submit sitemap**;\n4. Enter a full sitemap URL in the **Submit sitemap** field and click **Submit**.\n\n## Conclusion\n\nCreating a sitemap for your Gatsby website is a strategic move towards improving SEO and making your content more accessible to search engines.\n\nThe `gatsby-plugin-sitemap` simplifies this process, allowing you to focus on creating compelling content while ensuring that search engines can easily discover and index your pages.\n\nBy following these steps and customizing your sitemap, you can increase visibility, and ultimately optimize your website’s performance.\n","excerpt":"Creating a sitemap is an essential step towards enhancing the visibility and SEO performance of your Gatsby website. A sitemap assists search engines in…","tableOfContents":{"items":[{"url":"#the-importance-of-a-sitemap","title":"The Importance of a Sitemap"},{"url":"#step-1-install-the-gatsby-plugin","title":"Step 1: Install the Gatsby Plugin"},{"url":"#step-2-customize-your-sitemap","title":"Step 2: Customize Your Sitemap"},{"url":"#step-3-update-your-robotstxt-file","title":"Step 3: Update your robots.txt file"},{"url":"#step-4-test-and-deploy","title":"Step 4: Test and Deploy"},{"url":"#step-5-submit-to-search-engines","title":"Step 5: Submit to search engines","items":[{"url":"#how-to-submit-a-sitemap-to-google-search-console","title":"How to submit a sitemap to Google Search Console"},{"url":"#how-to-submit-a-sitemap-to-bing-webmaster-tools","title":"How to submit a sitemap to Bing Webmaster Tools"}]},{"url":"#conclusion","title":"Conclusion"}]},"fields":{"slug":"/blog/ultimate-gatsby-seo-guide/how-to-create-a-sitemap/","timeToRead":{"minutes":4.37,"words":874}},"frontmatter":{"title":"Ultimate Gatsby SEO Guide: How to create a sitemap?","authors":["Bartosz Łaniewski"],"keywords":["Gatsby","SEO"],"language":"en","description":null,"dateCreated":"December 11, 2023","dateCreatedMeta":"2023-12-12 00:00:00 +0100","dateUpdated":"December 25, 2023","dateUpdatedMeta":"2023-12-26 00:00:00 +0100","datePublished":"December 11, 2023","datePublishedMeta":"2023-12-12 00:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/ultimate-gatsby-seo-guide/how-to-create-a-sitemap.md"}}]}},"staticQueryHashes":["1271460761","3216310583","991007626"],"slicesMap":{}}