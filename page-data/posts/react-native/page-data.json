{"componentChunkName":"component---src-templates-blog-posts-tsx","path":"/posts/react-native/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://laniewski.me"}}},"pageContext":{"keyword":"React Native","data":[{"id":"683df14a-e3e7-5b97-834b-d4071070c06a","excerpt":"Filler is the first mobile game I ever created with React Native. It started as an experiment to learn more about algorithms, animations…","body":"\n[Filler](https://filler.laniewski.me/) is the first mobile game I ever created with React Native. It started as an experiment to learn more about algorithms, animations, and the platform itself.\n\n## Introduction\n\nI initially created Filler when I was ~15 years old. The idea came up as I was thinking of simple projects I could work on to learn more about web development and data structures. It was later on that I learned there was already a similar (and quite popular back in the ’90s) game, called _\"Lights Out\"_.\n\n> Lights Out is an electronic game released by Tiger Electronics in 1995. The game consists of a 5 by 5 grid of lights. When the game starts, a random number or a stored pattern of these lights is switched on. Pressing any of the lights will toggle it and the adjacent lights. The goal of the puzzle is to switch all the lights off, preferably in as few button presses as possible. – [Wikipedia](https://en.wikipedia.org/wiki/Lights_Out_(game))\n\nThere are, however, a few differences between the original and my game. In Filler:\n1. grids can be of any size, not only $$5 \\times 5$$;\n2. the goal is to switch all the lights on, not off;\n\nThe technology stack is pretty standard for the React ecosystem:\n\n- [Expo](https://expo.dev/)\n- [TypeScript](https://www.typescriptlang.org/)\n- [React Navigation](https://reactnavigation.org/)\n- [Styled Components](https://styled-components.com/)\n\n## Development\n\n### Internationalization\n\nI used [`expo-localization`](https://docs.expo.dev/versions/latest/sdk/localization/) and [`i18n-js`](https://github.com/fnando/i18n-js) to localize my application. The internationalization setup is pretty straightforward:\n\n```ts\nimport * as Localization from \"expo-localization\";\nimport i18n from \"i18n-js\";\n\nimport en from \"./strings/en.json\";\nimport fr from \"./strings/fr.json\";\nimport pl from \"./strings/pl.json\";\n\ni18n.fallbacks = true;\ni18n.translations = { en, pl, fr };\ni18n.defaultLocale = \"en\";\ni18n.locale = Localization.locale;\n\nexport { i18n };\n```\n\n…then, I could simply import `i18n` and use it in the application as follows:\n\n```tsx\n<Button>{i18n.t(\"menu.campaignButton\")}</Button>\n```\n\nTo make my tests independent of the translations, I mocked the `i18n-js` library and made the `i18n.t` function return the translation key instead of the translation itself:\n\n```ts\njest.mock(\"i18n-js\", () => {\n  return {\n    ...jest.requireActual(\"i18n-js\"),\n    t: jest.fn((key) => key),\n  };\n});\n```\n\n…having that, I could safely update the copy without breaking the integration tests:\n\n```tsx\nit(\"should reset the board on ’Reset’ button click\", () => {\n  const view = render(<Game />);\n\n  fireEvent.press(view.getByText(\"header.resetBtn\"));\n  // …\n});\n```\n\nI was not afraid to break anything in the user interface because my application contains visual regression tests. It allows me to ensure that my application appears to the end-user as it was originally intended to and I can catch visual regressions with ease.\n\n### Animations\n\nI used [`react-native-reanimated`](https://github.com/software-mansion/react-native-reanimated) to create all animations in the game. The main reason behind this choice was that the animations run on the native thread – it’s a great animation library performance-wise. It comes with an imperative and a declarative API.\n\n#### Imperative API\n\nI used the imperative functions and hooks for the `GridCell` component. I wanted to interpolate between two colors based on the `checked` prop. It was possible thanks to the `interpolateColor` helper:\n\n```tsx {2, 5-11, 15}\nfunction GridCell({ checked }: { checked: boolean }) {\n  const colorProgress = useSharedValue(checked ? 1 : 0);\n\n  // Interpolate between `empty` and `checked` color based on progress:\n  const animatedStyles = useAnimatedStyle(() => ({\n    backgroundColor: interpolateColor(\n      colorProgress.value,\n      [0, 1],\n      [theme.emptyCellColor, theme.checkedCellColor]\n    ),\n  }), [theme, colorProgress]);\n\n  // Change progress to 0-1 on `checked` change:\n  React.useEffect(() => {\n    colorProgress.value = withTiming(checked ? 1 : 0);\n  }, [checked, colorProgress]);\n\n  return <Cell style={animatedStyles} />\n}\n```\n\n#### Declarative API\n\nThere’s also a higher-level API that I used to progressively reveal content on the success screen. I didn’t need anything fancy here, just some entering animations with delays and the declarative API does a great job for such things:\n\n```tsx {6, 10, 14}\nfunction ScoreStars({ score }: { score: number }) {\n  const delay = 250;\n\n  return (\n    <Stars>\n      <Animated.View entering={Swing.delay(delay * 0)}>\n        {score < 1 ? <GrayStar /> : <GoldStar />}\n      </Animated.View>\n\n      <Animated.View entering={Swing.delay(delay * 1)}>\n        {score < 2 ? <GrayStar /> : <GoldStar />}\n      </Animated.View>\n\n      <Animated.View entering={Swing.delay(delay * 2)}>\n        {score < 3 ? <GrayStar /> : <GoldStar />}\n      </Animated.View>\n    </Stars>\n  );\n};\n```\n\n…where `Swing` is a custom [keyframe](https://docs.swmansion.com/react-native-reanimated/docs/api/LayoutAnimations/keyframeAnimations/) I created:\n\n```tsx\nconst Swing = () =>\n  new Keyframe({\n    0: { transform: [{ rotate: \"0deg\" }] },\n    20: { transform: [{ rotate: \"15deg\" }] },\n    40: { transform: [{ rotate: \"-10deg\" }] },\n    60: { transform: [{ rotate: \"5deg\" }] },\n    80: { transform: [{ rotate: \"-5deg\" }] },\n    100: { transform: [{ rotate: \"0deg\" }] },\n  });\n```\n\n### Monetization\n\nAfter the gameplay was implemented, I started working on integrating ads into the application using Google’s AdMob platform. The monetization model is pretty standard in the mobile industry. I decided to show:\n- an Interstitial Ad when the user completes a level (cap at 1 impression every 5 minutes per user);\n- a Rewarded Ad to unlock the solution w/ solver.\n\nI used [`react-native-google-mobile-ads`](https://github.com/invertase/react-native-google-mobile-ads) (and had a chance to contribute a little bit to the library as well!) to implement the advertising.\n\n#### Interstitial Ad\n\nI created a hook to easily check whether the advertisement has been watched or not.\n\n```tsx\nfunction useInterstitialAd() {\n  const { isLoaded, isClosed, error, load, show } = nativeUseInterstitialAd(\n    \"<AD_UNIT_ID>\",\n    {\n      requestNonPersonalizedAdsOnly: true,\n    }\n  );\n\n  const isError = error !== undefined;\n  const isAdWatched = isClosed || isError;\n\n  // Start loading the interstitial straight away:\n  React.useEffect(() => {\n    load();\n  }, [load]);\n\n  // Show the interstitial once loaded:\n  React.useEffect(() => {\n    if (isLoaded) {\n      show();\n    }\n  }, [isLoaded, show]);\n\n  return { isAdWatched };\n}\n```\n\n…then, I could very simply disable the \"Next level\" button until the ad has been watched:\n\n```tsx\nconst { isAdWatched } = useInterstitialAd();\n\n<Button disabled={!isAdWatched} onPress={handleExit}>\n  Next level\n</Button>\n```\n\n#### Rewarded Ad\n\nRewarded ads need a trigger and an explicit user interaction to show. I decided to go with a React Render Props pattern for a nice DX:\n\n```tsx\n<RewardedAd onSuccess={showSolution}>\n  {({ trigger, isAdLoading }) => (\n    <ActionButton onPress={trigger} processing={isAdLoading}>\n      Show solution\n    </ActionButton>\n  )}\n</RewardedAd>\n```\n\n`RewardedAd` hides a lot of boilerplate, but basically, it listens for events and handles the various errors that can occur.\n\n## Challenges\n\n### Permissions\n\n<Alert type=\"warning\">\n\nBy default, Expo adds a lot of unnecessary permission which can discourage the user from installing your application.\n</Alert>\n\nOnce released on Google Play, I noticed that the app had unnecessary permission listed. It required pretty much every permission available but needed none to work. To remove unused permissions, I had to modify `android/app/src/main/AndroidManifest.xml` as follows (note the `tools:node=\"remove\"` on `uses-permission`):\n\n```xml\n<manifest xmlns:tools=\"http://schemas.android.com/tools\" xmlns:android=\"http://schemas.android.com/apk/res/android\">\n  <uses-permission android:name=\"android.permission.VIBRATE\" />\n  <uses-permission android:name=\"android.permission.INTERNET\" />\n  <uses-permission tools:node=\"remove\" android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" />\n  <uses-permission tools:node=\"remove\" android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n  <uses-permission tools:node=\"remove\" android:name=\"android.permission.READ_PHONE_STATE\" />\n  <uses-permission tools:node=\"remove\" android:name=\"android.permission.RECORD_AUDIO\" />\n  <uses-permission tools:node=\"remove\" android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" />\n  <uses-permission tools:node=\"remove\" android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n</manifest>\n```\n\n### Performance\n\nI use my old [Asus ZenFone 3 Max 5.2](https://www.gsmchoice.com/en/catalogue/asus/zenfone3maxzc520tl/) as a benchmark – if a game works nicely on this device, I can sleep soundly because it means it will run on pretty much anything. My aim I always to get a stable 60 FPS for a nice user experience.\n\nIt was quite hard to achieve at first for several reasons:\n1. **Initially, I used [`react-native-animatable`](https://github.com/oblador/react-native-animatable) for animations:** it had noticeably worse performance than `react-native-reanimated`;\n2. **There were some redundant re-renders:** once I memorized some expensive components and calculation results, it improved the performance;\n3. **I was using JSC instead of [Hermes](https://engineering.fb.com/2019/07/12/android/hermes/):** once I migrated to Hermes, the performance improved greatly. Also, <abbr title=\"Time to Interaction\">TTI</abbr>, application size and memory utilization decreased a lot;\n\nIt turned out that React Native with Hermes can perform well enough to provide a nice UX, even on my old phone.\n\n### Sounds\n\nThere’s an issue with playing the same [`Audio`](https://docs.expo.dev/versions/latest/sdk/audio/) multiple times: the sound works well the first time, but the other times it seems that the sound isn’t playing from the start but has a shift of some milliseconds.\n\nThe solution I use is to preload multiple copies of [`Audio`](https://docs.expo.dev/versions/latest/sdk/audio/) and play the next sample when needed. My implementation looks as follows:\n\n```ts\nimport { Audio } from \"expo-av\";\nimport { AVPlaybackSource } from \"expo-av/build/AV\";\n\nclass Sound {\n  static COPIES = 3;\n  static INDEX = 0;\n  static assets: Record<string, Audio.Sound> = {};\n\n  static loadAsync(library: Record<string, AVPlaybackSource>) {\n    const promisesForCopies = Object.entries(library).flatMap(\n      ([name, path]: [string, AVPlaybackSource]) => {\n        // Make n = Sound.COPIES copies:\n        return Array.from(Array(Sound.COPIES)).map((_, i) => {\n          const soundNameWithIndex = `${name}-${i}`;\n\n          Sound.assets[soundNameWithIndex] = new Audio.Sound();\n          return Sound.assets[soundNameWithIndex].loadAsync(path);\n        });\n      }\n    );\n\n    return Promise.all(promisesForCopies);\n  }\n\n  static async play(name: string, volume = 1) {\n    try {\n      Sound.INDEX = (Sound.INDEX + 1) % Sound.COPIES;\n\n      const soundNameWithIndex = `${name}-${Sound.INDEX}`;\n      const soundSample = Sound.assets[soundNameWithIndex];\n\n      if (soundSample) {\n        await soundSample.setVolumeAsync(volume);\n        await soundSample.playFromPositionAsync(0);\n      } else {\n        throw new Error(`Sound ${name} does not exist`);\n      }\n    } catch (error) {\n      // Silent error…\n    }\n  }\n}\n```\n\n### Solver\n\nI wanted to create a solver to monetize the game. It turned out to be quite a popular problem with a lot of resources online, so I won’t go into much detail. It just required a bit of linear algebra.\n\nA board can be modeled mathematically as a vector over $$\\mathbb{F}_2$$, a [field](https://en.wikipedia.org/wiki/GF(2)) containing only the elements 0 and 1 (for light on and off respectively). We can write each possible board position and each possible move as a vector over $$\\mathbb{F}_2$$. That means that:\n- pressing a cell an even number of times has no effect;\n- the order in which we press the cells does not matter;\n\nTo solve the board, we need to find a combination of these move vectors which adds up to give the current board, since that will cancel with the board, turning all of the lights on. There is a systematic way of solving this kind of vector problem called [Gaussian Elimination](https://en.wikipedia.org/wiki/Gaussian_elimination).\n\n```ts\nfunction solve(width: number, height: number, state: boolean[]): number[] {\n  const moveVector = buildMoveVector(width, height);\n  const moveMatrix = buildMoveMatrix(moveVector, state);\n  const solution = getLastRow(rref(moveMatrix));\n\n  return solution;\n}\n```\n\nA nice video explaining this in detail can be found [here](https://www.youtube.com/watch?v=oCHCD_-nhg4).\n\n## Conclusion\n\nIt was a fun experience to rebuild the same game several years later after gathering all of my commercial experience and still being able to learn new things along the journey. So far, I’ve got 200+ downloads and generated $0.20 in ad revenue, but hey, the learnings are priceless!\n","tableOfContents":{"items":[{"url":"#introduction","title":"Introduction"},{"url":"#development","title":"Development","items":[{"url":"#internationalization","title":"Internationalization"},{"url":"#animations","title":"Animations"},{"url":"#monetization","title":"Monetization"}]},{"url":"#challenges","title":"Challenges","items":[{"url":"#permissions","title":"Permissions"},{"url":"#performance","title":"Performance"},{"url":"#sounds","title":"Sounds"},{"url":"#solver","title":"Solver"}]},{"url":"#conclusion","title":"Conclusion"}]},"fields":{"slug":"/blog/2022-06-27-case-study-filler/","timeToRead":{"minutes":8.52}},"frontmatter":{"dateCreated":"June 26, 2022","dateCreatedMeta":"2022-06-27 00:00:00 +0100","dateUpdated":"November 30, 2023","dateUpdatedMeta":"2023-12-01 00:00:00 +0100","datePublished":"June 26, 2022","datePublishedMeta":"2022-06-27 00:00:00 +0100","title":"Case study: Filler (a React Native game)","authors":["Bartosz Łaniewski"],"language":"en","keywords":["Case Study","Gamedev","React Native"],"description":null},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/2022-06-27-case-study-filler/index.md"}},{"id":"2b4449d8-704e-59c2-98a4-5640ac88e48f","excerpt":"Tilt Copters is a relatively simple game created with [pixi.js] and Expo. This is a project I’ve started to learn more about porting web…","body":"\n[Tilt Copters] is a relatively simple game created with [pixi.js] and Expo. This is a project I’ve started to learn more about porting web libraries to React Native but also about game architecture and monetization.\n\n## Introduction\n\nTilt Copters is a casual endless game. The user picks the character he wishes to pilot and can explore various maps. The character can be moved by tilting the device. The user has to avoid obstacles and the higher he gets, the faster and more challenging the game becomes.\n\nTechnology stack:\n\n- [Expo](https://expo.dev/)\n- [TypeScript](https://www.typescriptlang.org/)\n- [React Navigation](https://reactnavigation.org/)\n- [Styled Components](https://styled-components.com/)\n- [Pixi.js](https://pixijs.com/) with [my port](https://github.com/Bartozzz/expo-pixi) of the library\n- [Redux Toolkit](https://redux-toolkit.js.org/)\n- [Zustand](https://github.com/pmndrs/zustand)\n\n## Development\n\nI am well aware that React Native might not be ready for game development just yet. I picked it out of curiosity – I wanted to see where the limits of this technology are.\n\nNevertheless, React Native has its benefits. The main advantage over native solutions is that it’s easy to make cross-platform applications for mobile, desktop, and web while still having the option to interop native code when necessary. It has an established ecosystem, community and is backed by a lot of big companies (industry momentum).\n\n### Architecture\n\nLet’s start by analyzing the elements and features that we have in the game. We have:\n- a character and a map defined by a background, pipes, and coins;\n- a controller system that hooks to the device accelerometer;\n- a collision system that handles pipes and coin collisions;\n\n#### Game Manager\n\nThe Game Manager is a [mediator](https://refactoring.guru/design-patterns/mediator) and serves as an aggregator for the Game Objects.\n\n```ts\nexport class GameManager {\n  public constructor({ context }: EngineConfiguration) {\n    this.application = new PIXI.Application({ context });\n\n    // Updates:\n    this.ticker.add(() => {\n      if (this.store.state === \"isPlaying\") {\n        // Updates:\n        this.background.update(this.speed);\n        this.character.update(this.speed);\n        this.pipes.forEach((pipe) => pipe.update(this.speed));\n        this.coins.forEach((coin) => coin.update(this.speed));\n\n        // Collision check:\n        this.obstaclesManager.check();\n\n        // Speed increase:\n        this.speed += configuration.game.acceleration;\n      }\n    });\n\n    // Controls:\n    this.controlManager.subscribe(ControlManager.MOVE, (data: number) => {\n      this.character.move(data);\n    });\n\n    // Collisions:\n    this.obstaclesManager.subscribe(ObstaclesManager.PIPE_COLLISION, () => {\n      this.lose();\n    });\n    this.obstaclesManager.subscribe(ObstaclesManager.PIPE_PASSED, (pipe) => {\n      pipe.score();\n      this.store.incrementScore();\n    });\n    this.obstaclesManager.subscribe(ObstaclesManager.COIN_COLLISION, (coin) => {\n      coin.score();\n      this.store.incrementCoins();\n    });\n  }\n\n  public initialize(gameConfig: GameConfiguration) {\n    // …\n  }\n  public reset() {\n    // …\n  }\n  public destroy() {\n    // …\n  }\n\n  public prepare() {\n    this.store.setState(\"isIdle\");\n    this.application.start();\n  }\n  public play() {\n    this.store.setState(\"isPlaying\");\n    this.application.start();\n  }\n  public lose() {\n    this.store.setState(\"isGameOver\");\n    this.application.stop();\n  }\n}\n\n```\n\n#### Game Objects\n\nThe Game Objects describe elements in the game world (character, background, pipe, coin). All these elements are implementing the `GameObject` interface:\n\n```ts\nexport interface GameObject {\n  update(delta: number): void;\n  destroy(): void;\n  getBoundingBoxes(): BoundingBox[];\n}\n```\n\n### Navigation\n\nI used [`@react-navigation/stack`](https://reactnavigation.org/docs/stack-navigator/) to handle all in-game navigation. I created [custom interpolators](https://reactnavigation.org/docs/stack-navigator/#animations) to give the user an illusion that the entire game is one big canvas just sliding down or up based on the view that we want to show.\n\nBelow is the code that I used to customize the transition when navigating from the menu to the shop and vice-versa:\n\n```ts\nexport function forShopInterpolator({\n  index,\n  current,\n  next,\n  inverted,\n  layouts: { screen },\n}: StackCardInterpolationProps): StackCardInterpolatedStyle {\n  const isFirst = index === 0;\n\n  const progress = add(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: \"clamp\",\n    }),\n    next\n      ? next.progress.interpolate({\n          inputRange: [0, 1],\n          outputRange: [0, 1],\n          extrapolate: \"clamp\",\n        })\n      : 0\n  );\n\n  const translateY = multiply(\n    progress.interpolate({\n      inputRange: [0, 1, 2],\n      outputRange: [\n        screen.height,\n        isFirst ? 0 : 0,\n        isFirst ? -screen.height : 0,\n      ],\n    }),\n    inverted\n  );\n\n  return {\n    cardStyle: {\n      overflow: \"hidden\",\n      transform: [{ translateY }],\n    },\n  };\n}\n```\n\n### Responsiveness\n\nUnlike most game engines, `pixi.js` does not handle multiple resolutions out of the box. You’ll have to manually stretch the game viewport to match the device screen size.\n\nMy approach is to use a single base resolution and then fit it into everything else. The one I picked is 375x812pt (iPhone X). Think of this setting as the \"design size\", i.e. the size of the area that you work with when creating textures.\n\n```ts\nimport { Dimensions } from \"react-native\";\n\nconst window = Dimensions.get(\"window\");\n\nexport const targetWidth = 375;\nexport const targetHeight = 812;\nexport const scale = (window.width * window.scale) / targetWidth;\n\nexport const canvas = {\n  width: targetWidth,\n  height: targetHeight,\n  scale: scale,\n};\n```\n\nThen, I just had to set the [`PIXI.Application`](https://pixijs.download/v4.8.9/docs/PIXI.Application.html#Application) `width`, `height` and `resolution` as follows:\n\n```ts {7-9}\nexport class GameManager {\n  private application!: PIXI.Application;\n\n  public constructor({ context }: EngineConfiguration) {\n    this.application = new PIXI.Application({\n      context,\n      width: configuration.canvas.width,\n      height: configuration.canvas.height,\n      resolution: configuration.canvas.scale,\n    });\n  }\n}\n```\n\n`resolution` will stretch the canvas to fit the whole screen while maintaining aspect ratios no matter the resolution. The scene is rendered and then scaled to fit the screen.\n\n### State management\n\nI used [zustand](https://github.com/pmndrs/zustand) for game state management. It is a barebones state-management solution using simplified flux principles. It’s really easy to use and framework agnostic (no context providers are necessary), so I can use it in React (UI) and game managers (logic). My game store looks as follows:\n\n```ts\nimport create from \"zustand\";\nimport createVanilla from \"zustand/vanilla\";\nimport { combine } from \"zustand/middleware\";\n\ninterface State {\n  state: \"isIdle\" | \"isPlaying\" | \"isGameOver\";\n  score: number;\n  coins: number;\n}\n\nconst initialState: State = {\n  state: \"isIdle\",\n  score: 0,\n  coins: 0,\n};\n\nexport const gameStore = createVanilla(\n  combine(initialState, (set) => ({\n    reset: () => set(initialState),\n    setState: (payload: State[\"state\"]) =>\n      set((state) => ({ state: payload })),\n    incrementScore: (payload = 1) =>\n      set((state) => ({ score: Math.max(0, state.score + payload) })),\n    incrementCoins: (payload = 1) =>\n      set((state) => ({ coins: Math.max(0, state.coins + payload) })),\n  }))\n);\n\nexport const useGameStore = create(gameStore);\n```\n\n#### Usage in managers\n\n```ts {2-4, 8, 14, 18}\nexport class GameManager {\n  private get store() {\n    return gameStore.getState();\n  }\n\n  public constructor({ context }: EngineConfiguration) {\n    this.ticker.add(() => {\n      if (this.store.state === \"isPlaying\") {\n        // Do the updates…\n      }\n    });\n\n    this.obstaclesManager.subscribe(ObstaclesManager.PIPE_PASSED, () => {\n      this.store.incrementScore();\n    });\n\n    this.obstaclesManager.subscribe(ObstaclesManager.COIN_COLLISION, () => {\n      this.store.incrementCoins();\n    });\n  }\n}\n```\n\n#### Usage in React\n\n```tsx {2}\nexport function GameScore() {\n  const score = useGameStore((state) => state.score);\n\n  return <Text size=\"lg\">{score}</Text>;\n}\n```\n\n<Alert type=\"info\">\n\n  I used [Redux Toolkit](https://redux-toolkit.js.org/) for the user state (i.e. purchased items) and [`redux-persist`](https://github.com/rt2zz/redux-persist) for persistence. There are no particular reasons why I used Redux over Zustand or any other solution.\n</Alert>\n\n## Challenges\n\n### Expo and libraries\n\nThere’s an official library called [`expo-pixi`](https://github.com/expo/expo-pixi) originally developed by Evan Bacon. This is the first search result when looking for PixiJS for Expo/React Native. I tried using this library but quickly abandoned it because of plenty of issues it has. Instead, I created my port with better compatibility. It can be found on [`Bartozzz/expo-pixi`](https://github.com/Bartozzz/expo-pixi).\n\n#### Issue #1: incompatible with Expo 43 ([#221](https://github.com/expo/expo-pixi/issues/221))\n\n`expo-pixi` uses [`expo-asset-utils`](https://github.com/expo/expo-asset-utils) which is incompatible with Expo SDK 43 and above. This is because Expo SDK 43 [deprecated the `react-native-unimodules` package](https://blog.expo.dev/whats-new-in-expo-modules-infrastructure-7a7cdda81ebc):\n\n> The `react-native-unimodules` package is deprecated as of SDK 43, and the module system and autolinking implementation now live in the expo package instead.\n\nThe solution was to migrate from [`expo-asset-utils`](https://github.com/expo/expo-asset-utils) to [`expo-asset`](https://docs.expo.dev/versions/latest/sdk/asset/):\n\n```diff\n-import { resolveAsync } from \"expo-asset-utils\";\n+import { Asset } from \"expo-asset\";\n\nconst textureFromExpoAsync = async resource => {\n- const asset = await resolveAsync(resource);\n+ const asset = await Asset.fromModule(resource).downloadAsync();\n\n  return PIXI.Texture.from(asset);\n}\n```\n\n#### Issue #2: invalid dependencies ([#156](https://github.com/expo/expo-pixi/issues/156))\n\n1. `expo-pixi` does not have a locked-in version of `pixi-filters`. It downloads the latest version which is incompatible with pixi-js V4;\n2. `expo-pixi` requires `expo-gl` V4, which is incompatible with Expo SDK 40 and above;\n\nTo fix those issues, I updated the dependencies as follows:\n\n```diff\n{\n  \"dependencies\": {\n-   \"pixi-filters\": \"*\",\n+   \"pixi-filters\": \"2.7.1\",\n-   \"pixi.js\": \"^4.7.0\"\n+   \"pixi.js\": \"latest-4.x\"\n  },\n  \"peerDependencies\": {\n-   \"expo-gl\": \"~4.0.0\"\n+   \"expo-gl\": \"*\"\n  }\n}\n```\n\n#### Issue #3: side effects and library overwriting model\n\n`expo-pixi` overwrites `pixi.js` methods in a quite ugly way. It mutates the PIXI instance:\n\n```ts\nPIXI = {\n  ...PIXI,\n  Application: ExpoPIXIApplication,\n  Texture: {\n    ...PIXI.Texture,\n    from: (...props) => { /* … */ },\n    fromExpoAsync: textureFromExpoAsync,\n  },\n  Sprite: {\n    ...PIXI.Sprite,\n    fromExpoAsync: spriteFromExpoAsync,\n    from: (...props) => { /* … */ },\n  }\n}\n```\n\nThere are several issues with this approach:\n1. This is causing side effects, as PIXI is declared in the global scope;\n2. There was a mix of web-only and native-only code in a single file;\n\nTo solve the first issue, my approach was to simply extend PIXI classes and re-export new PIXI objects:\n\n```ts\nimport * as filters from \"pixi-filters\";\nimport * as PIXIInstance from \"pixi.js\";\n\nclass PIXIApplication extends PIXIInstance.Application {\n  // …\n}\n\nclass PIXISprite extends PIXIInstance.Sprite {\n  static from(asset) {\n    // …\n  }\n}\n\nclass PIXITexture extends PIXIInstance.Texture {\n  static from(asset) {\n    // …\n  }\n}\n\nexport const PIXI = {\n  ...PIXIInstance,\n  filters: {\n    ...PIXIInstance.filters,\n    ...filters,\n  },\n  Application: PIXIApplication,\n  Texture: PIXITexture,\n  Sprite: PIXISprite,\n};\n```\n\nWith this approach, I could safely remove the `sideEffects` flag from `package.json`:\n\n```diff\n{\n  \"name\": \"expo-pixi\",\n- \"sideEffects\": true,\n}\n```\n\nTo solve the second issue, I simply moved the web code to `pixi.ts`, and the native code to `pixi.native.ts`. This is described in detail in [React Native documentation: Platform-specific extensions](https://reactnative.dev/docs/platform-specific-code#platform-specific-extensions):\n\n> You can also use the `.native.js` extension when a module needs to be shared between NodeJS/Web and React Native but it has no Android/iOS differences. This is especially useful for projects that have common code shared among React Native and ReactJS.\n\n#### Issue #4: assets were not properly bundled on production build ([#66](https://github.com/expo/expo-pixi/issues/66), [#92](https://github.com/expo/expo-pixi/issues/92), [#103](https://github.com/expo/expo-pixi/issues/103))\n\n<Alert type=\"warning\">\n\n  This was particularly hard to debug because it only happens on release (production) Android builds. This issue does not happen on development and Web/iOS platforms.\n</Alert>\n\nThere are issues with `expo-gl` where `.jpg` and `.png` textures would not load in Android release variants. This is an issue (actually, several issues) with Expo and thus it was quite hard to fix it in the package itself. The fixes consist of several workarounds described below:\n\n##### Invalid file scheme\n\nWhen built as APK, the image asset resolves to something like:\n\n```\nfile:/data/user/0/…/.expo-internal/some-hash.png\n```\n\nThe problem is that [`expo-gl#loadImage`](https://github.com/expo/expo/blob/master/packages/expo-gl-cpp/cpp/EXGLImageUtils.cpp#L126) expects `file://` scheme and not `file:` (note the missing slashes). To solve this issue, we have to manually add the slashes to `asset.localUri`s, as follows:\n\n```ts\n// An asset uri might start with `file:` and not `file://`.\n// `expo-gl` expects a texture asset to have the slashes. Enforce the slashes.\nfunction fixFileUri(uri: string) {\n  // https://github.com/expo/expo/blob/master/packages/expo-gl-cpp/cpp/EXGLImageUtils.cpp#L126\n  return uri.startsWith(\"file:\") && !uri.startsWith(\"file://\")\n    ? \"file://\" + uri.substring(5)\n    : uri;\n}\n\nasync function textureFromAssetAsync(resource: string | number) {\n  const asset = await Asset.fromModule(resource).downloadAsync();\n  asset.localUri = fixFileUri(asset.localUri!);\n\n  return PIXITexture.from(asset as any);\n}\n```\n\n##### Invalid path for images\n\nWhen you [bundle assets for your Android APK](https://developer.android.com/guide/topics/resources/providing-resources), the assets go to the `res` folder, but the subfolder they end up is dependent on the resource type. Bitmap files (`.png`, `.jpg`, `.gif`, etc.) or XML files that are compiled into drawable resource subtypes go to `res/drawables` directory.\n\nThe issue is that in production, images are moved to the `res/drawables` directory (as you would expect) but `expo-file-system` [`FileSystem#downloadAsync`](https://github.com/expo/expo/blob/main/packages/expo-file-system/android/src/main/java/expo/modules/filesystem/FileSystemModule.kt#L911=) only checks the `raw` directory! Because of that, I was unable to load textures for `expo-pixi` on Android.\n\nI don’t know any viable workaround for this issue. What worked for me was changing the image extensions to `.xjpg` and `.xpng`. I also had to update the `textureFromAssetAsync` to change `asset.type` to the correct extension and recalculate `asset.width` and `asset.height` as follows:\n\n```ts {22,24-26}\n// https://github.com/expo/expo/blob/main/packages/expo-asset/src/ImageAssets.ts\nfunction getImageInfo(url: string): Promise<{\n  width: number;\n  height: number;\n}> {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onerror = reject;\n    img.onload = () => {\n      resolve({\n        width: img.width,\n        height: img.height,\n      });\n    };\n    img.src = url;\n  });\n}\n\nasync function textureFromAssetAsync(resource: string | number) {\n  const asset = await Asset.fromModule(resource).downloadAsync();\n  asset.localUri = fixFileUri(asset.localUri!);\n  asset.type = asset.type.replace(\"x\", \"\"); // xpng => png, xjpg => jpg\n\n  const { width, height } = await getImageInfo(asset.localUri);\n  asset.width = width;\n  asset.height = height;\n\n  return PIXITexture.from(asset as any);\n}\n```\n\nI also needed to update `metro.config.js` to allow `.xjpg` and `.xpng` extensions:\n\n```ts\nconst { getDefaultConfig } = require(\"@expo/metro-config\");\nconst defaultConfig = getDefaultConfig(__dirname);\n\n// Added .xjpg and .xpng extensions for sprites:\ndefaultConfig.resolver.assetExts.push(\"xjpg\");\ndefaultConfig.resolver.assetExts.push(\"xpng\");\n\nmodule.exports = defaultConfig;\n```\n\n### Game performance\n\nMy aim I always to get at least a stable 60 FPS on all of the devices I have. Here are the results:\n\n- [iPhone X](https://www.gsmchoice.com/en/catalogue/apple/iphonex/): 60 FPS;\n- [iPhone 13 Pro](https://www.gsmchoice.com/en/catalogue/apple/iphone13pro/): 60 FPS;\n- [Samsung S8](https://www.gsmchoice.com/en/catalogue/samsung/galaxys8/): 50-60 FPS;\n- [Asus ZenFone 3 Max 5.2](https://www.gsmchoice.com/en/catalogue/asus/zenfone3maxzc520tl/): 40-60 FPS.\n\nAndroid phones have some troubles with garbage collection and there’s a ~10 FPS performance drop when going back and forth from the menu to the game screen.\n\n### React Native performance\n\nReact Native is performant overall and its capabilities are more than enough for standard user interfaces. However, when combined with game rendering and intensive processing in the game loop, you might want to limit React renders.\n\nI wanted to show the user the distance he flew during the gameplay. The natural place I wanted to put the score was the navigation bar from React Navigation but it resulted in a 10 FPS performance drop. Two options were presented:\n\n1. I could render the score in a custom component, or,\n2. I could render the score on the canvas;\n\nThe second solution was not possible to implement because `expo-pixi` has [no support for rendering text on the canvas](https://github.com/expo/expo-pixi/issues/20). Moving the score to a custom component had no big impact on the performance, but required some code to support notch on Apple devices. Later on, I decided to display the number of pipes passed instead and I was able to use the React Navigation back.\n\n### Android differences\n\n<Alert type=\"warning\">\n\n  Always test your application on all platforms before release. React Native offers cross-platform compatibility but some native differences have to be overcome manually.\n</Alert>\n\nSome of the deviations were already described in [Expo and libraries](#expo-and-libraries) but there are more! The main differences between Android and other platforms are:\n\n- **Difference in default UI/UX:** by default the stack navigator is configured to have the familiar iOS and Android look & feel: new screens slide in from the right on iOS and use OS default animation on Android. There are also visual differences that need to be patched to provide similar game UI/UX across platforms;\n- **No full fonts support:** `font-weight` and `font-style` [are not supported](https://stackoverflow.com/a/38820631). You have to load all the font variants as separate fonts with a different `font-family` name;\n- **No full shadows support:** Android does not have native support for CSS-like shadows. You have to use the [`elevation`](https://reactnative.dev/docs/view-style-props#elevation-android) property or 3rd party libraries like [`react-native-shadow`](https://www.npmjs.com/package/react-native-shadow-2);\n- **Poor styling support**: for example, when making a text outline using `text-shadow`, we have to keep a small blur radius because Android won’t render it at all when it’s set to 0 (`text-shadow: 0 2px 0.00001px black`);\n- **Inconsistent API:** on Android devices, the accelerometer data is reversed and we have to normalize it before usage:\n    ```ts\n    import { Accelerometer } from \"expo-sensors\";\n    import { Platform } from \"react-native\";\n    import { PubSub } from \"../helpers/PubSub\";\n\n    export class ControlManager extends PubSub {\n      static MOVE = \"MOVE\";\n\n      public register() {\n        Accelerometer.addListener((accelerometerData) => {\n          const data =\n            // For some reason on Android the signs are flipped:\n            Platform.OS === \"android\"\n              ? -accelerometerData.x\n              : accelerometerData.x;\n\n          this.publish(ControlManager.MOVE, data);\n        });\n      }\n\n      public destroy() {\n        Accelerometer.removeAllListeners();\n      }\n    }\n    ```\n\n## Conclusion\n\nMaking a simple game was a great way to learn the Expo internals and limitations, but `expo-pixi` it’s not the best tool for the job:\n- there is a lack of support when it comes to `expo-pixi`;\n- there are plenty of bugs, especially on Android devices;\n- the performance is not great overall;\n\nBecause of that, I started working on my game library for React Native that uses [`react-native-skia`](https://github.com/Shopify/react-native-skia), a high-performance React Native Graphics library under the hood.\n\n[Tilt Copters]: https://tiltcopters.laniewski.me\n[PixiJS]: https://pixijs.com/\n","tableOfContents":{"items":[{"url":"#introduction","title":"Introduction"},{"url":"#development","title":"Development","items":[{"url":"#architecture","title":"Architecture"},{"url":"#navigation","title":"Navigation"},{"url":"#responsiveness","title":"Responsiveness"},{"url":"#state-management","title":"State management"}]},{"url":"#challenges","title":"Challenges","items":[{"url":"#expo-and-libraries","title":"Expo and libraries"},{"url":"#game-performance","title":"Game performance"},{"url":"#react-native-performance","title":"React Native performance"},{"url":"#android-differences","title":"Android differences"}]},{"url":"#conclusion","title":"Conclusion"}]},"fields":{"slug":"/blog/2022-06-11-case-study-tilt-copters/","timeToRead":{"minutes":13.08}},"frontmatter":{"dateCreated":"June 10, 2022","dateCreatedMeta":"2022-06-11 00:00:00 +0100","dateUpdated":"November 30, 2023","dateUpdatedMeta":"2023-12-01 00:00:00 +0100","datePublished":"June 10, 2022","datePublishedMeta":"2022-06-11 00:00:00 +0100","title":"Case study: Tilt Copters (a React Native game)","authors":["Bartosz Łaniewski"],"language":"en","keywords":["Case Study","Gamedev","React Native"],"description":null},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/2022-06-11-case-study-tilt-copters/index.md"}}]}},"staticQueryHashes":["1271460761","3216310583","991007626"],"slicesMap":{}}