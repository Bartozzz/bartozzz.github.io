{"componentChunkName":"component---src-templates-blog-posts-tsx","path":"/posts/react/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://laniewski.me"}}},"pageContext":{"keyword":"React","data":[{"id":"dd3c3697-6f84-5214-b627-3e35cce88fd5","body":"\nLazy loading is a well-known technique for improving performance and reducing the associated resource costs. It’s so effective that it’s even [being added to the web standard](https://github.com/whatwg/html/pull/3752) via the `loading=\"lazy\"` attribute. In this article, we will learn how to perform lazy resource loading and code splitting in React.\n\n> **Note:** at the time of writing this article, a lot of APIs are still in development and are not ready to be used in production.\n\n## Glossary\n\n> **Code splitting** […] allows you to split your code into various bundles which can then be loaded on demand or in parallel. It can be used to achieve smaller bundles and control resource load prioritization which, if used correctly, can have a major impact on load time. ~ [Webpack](https://webpack.js.org/guides/code-splitting/)\n\n> **Lazy loading** is a design pattern […] used to defer initialization of an object until the point at which it is needed. It can contribute to efficiency in the program’s operation if properly and appropriately used. […] The performance gains are especially significant if the initialization of the object is costly, such as in case of accessing network services. ~ [Wikipedia](https://en.wikipedia.org/wiki/Lazy_loading)\n\n## Problem\n\nA lot of <abbr title=\"Single-Page Application: a web application that loads once and dynamically updates as the response for user interactions.\">SPAs</abbr> nowadays are \"monolithic\" – there’s a giant JavaScript bundle that contains all of the application’s files. This bundle is required via a `<script>` tag, gets downloaded on the initial visit, and is hopefully cached. This results in:\n\n- a **longer initial load**: we download all of the app’s code, even if it’s not needed to perform the initial render or not used at all;\n- **faster application rendering and in-app navigation**: all of the components are already downloaded and don’t need to be lazily fetched.\n\nThis is the typical drawback of code-splitting: the initial page load is faster but each dynamic import degrades the visible in-app performance.\n\nDevelopers tend to provide visual feedback for each asynchronous action. It often results in an immense amount of loaders and it’s still badly perceived by users. Once the lazy components render, they can perform other asynchronous actions (like network requests) which adds another layer of loaders.\n\nAs a developer, you need to find the perfect balance between initial and dynamic loading and focus on creating great fallback experiences.\n\n## Solutions\n\nConcurrent React can partially render a tree without committing the result.\n\n### Code splitting\n\nReact 16.6 introduced [`React.lazy`](https://react.dev/reference/react/lazy) which allows us to perform code splitting and a [`Suspense`](https://react.dev/reference/react/Suspense) component which renders placeholders for lazy-loaded resources.\n\n```jsx\nimport React, { Suspense, lazy } from \"react\";\n\nconst Foo = lazy(() => import(\"./Foo\"));\nconst Bar = lazy(() => import(\"./Bar\"));\n\nconst LazyFooBar = () => (\n  <ErrorBoundary>\n    <Suspense maxDuration={1500} fallback={\"Loading…\"}>\n      <Foo />\n\n      <Suspense maxDuration={1000} fallback={\"Loading…\"}>\n        <Bar />\n      </Suspense>\n    </Suspense>\n  </ErrorBoundary>\n);\n```\n\nThe dynamic `import()` tells the bundler to exclude requested files from the main bundle. `React.lazy` returns a special component type that will suspend the render until it resolves or rejects The exact behavior is described in the following [RFC](https://github.com/reactjs/rfcs/blob/main/text/0064-lazy.md):\n\n> `React.lazy` accepts a Promise factory, and returns a new component type. When React renders that type for the first time, it triggers the Promise factory […]. If the Promise is fulfilled, React reads the `.default` value from it […], and uses it as a component type for rendering. If the Promise is rejected, the rejection is handled in the same way as React normally handles errors (by letting the nearest error boundary handle it). After the code has loaded, React caches the Promise result. Next renders of the components with this type become synchronous and have no extra cost.\n\n`Suspense` allows you to define a fallback placeholder which is displayed when the render is in the suspended state. It also allows you to configure the delay after which the fallback should be shown (via the `maxDuration` property). It will prevent the fallback component from showing up on fast networks.\n\n`Suspense` is quite similar to `ErrorBoundary`. In fact, you can think of `Suspense` as being the `try { … }` block whereas `ErrorBoundary` is the `catch (error) { … }` block.\n\n### Lazy loading and preloading\n\nReact team is working on an experimental library named [`react-cache`](https://github.com/facebook/react/tree/master/packages/react-cache). It provides APIs for implementing various caches for React applications. As it is dependent on some not-yet-released React APIs, this library should not be used in production.\n\n#### API calls\n\nOne of `react-cache` use cases is to suspend rendering on pending requests.\n\n```javascript\nconst FooListResource = unstable_createResource((query) => fetchFooList(query));\n```\n\nIn our render, we just read the data using the `FooListResource.read`. This method returns the response from the `unstable_createResource` Promise factory and tells the nearest parent `React.Suspense` to stop the rendering and display the fallback till the resource is ready. The implementation is simple:\n\n```jsx\nconst FooList = () => {\n  const response = FooListResource.read({\n    search: \"search string\",\n  });\n\n  return (\n    <ul>\n      {response.map((item) => (\n        <li key={item.id}>{item.text}</li>\n      ))}\n    </ul>\n  );\n};\n```\n\n#### Embedded documents\n\nYou can use `react-cache` to lazy load embedded documents, such as images, videos, scripts, stylesheets, and more. The implementation is quite similar to caching API calls. We start with creating an image resource:\n\n```javascript\nconst ImageResource = unstable_createResource(\n  (src) =>\n    new Promise((resolve, reject) => {\n      const img = new Image();\n      img.src = src;\n      img.onload = resolve;\n      // img.onerror = reject;\n    })\n);\n```\n\nNow, we need to create an alternative `img` component which will make use of the `ImageResource`. For this, we simply need to call `ImageResource.read(src)` – it will tell the nearest parent `React.Suspense` to stop the rendering and display the fallback till the image is fully loaded. The implementation is straightforward:\n\n```jsx\nconst Img = ({ src, ...props }) => {\n  ImageResource.read(src);\n\n  return <img src={src} {...props} />;\n};\n```\n\nNow, we can create a wrapper that will take care of providing the low-resolution fallback image for us – we just need to wrap the newly created `Img` component with a `React.Suspense` and provide a fallback image, as follows:\n\n```jsx\nconst LazyImg = ({ lowResSrc, highResSrc, ...props }) => (\n  <React.Suspense fallback={<img {...props} src={lowResSrc} />}>\n    <Img {...props} src={highResSrc} />\n  </React.Suspense>\n)\n```\n\nThere’s a GitHub project named `the-platform` which turns Web APIs into React Hooks and Suspense-friendly React components. It provides a set of lazy components out of the box, such as:\n\n- [`<Img>`](https://github.com/jaredpalmer/the-platform#img)\n- [`<Script>`](https://github.com/jaredpalmer/the-platform#script)\n- [`<Video>`](https://github.com/jaredpalmer/the-platform#video)\n- [`<Audio>`](https://github.com/jaredpalmer/the-platform#audio)\n- [`<Preload>`](https://github.com/jaredpalmer/the-platform#preload)\n- [`<Stylesheet>`](https://github.com/jaredpalmer/the-platform#stylesheet)\n\n## Resources\n\n1. https://legacy.reactjs.org/docs/code-splitting.html\n2. https://medium.com/@rossbulat/react-lazy-suspense-and-concorrent-react-breakdown-with-examples-2758de98cb1c\n3. https://github.com/palmerhq/the-platform\n4. https://youtube.com/watch?v=SCQgE4mTnjU\n5. https://www.youtube.com/watch?v=ByBPyMBTzM0\n","excerpt":"Lazy loading is a well-known technique for improving performance and reducing the associated resource costs. It’s so effective that it’s even being added…","tableOfContents":{"items":[{"url":"#glossary","title":"Glossary"},{"url":"#problem","title":"Problem"},{"url":"#solutions","title":"Solutions","items":[{"url":"#code-splitting","title":"Code splitting"},{"url":"#lazy-loading-and-preloading","title":"Lazy loading and preloading"}]},{"url":"#resources","title":"Resources"}]},"fields":{"slug":"/blog/2019-04-19-lazy-loading-and-code-splitting-in-react-apps/","timeToRead":{"minutes":5.365,"words":1073}},"frontmatter":{"title":"Lazy loading and code splitting in React","authors":["Bartosz Łaniewski"],"keywords":["React"],"language":"en","description":null,"dateCreated":"April 19, 2019","dateCreatedMeta":"2019-04-20 00:00:00 +0100","dateUpdated":"December 16, 2023","dateUpdatedMeta":"2023-12-16 13:10:00 +0100","datePublished":"April 19, 2019","datePublishedMeta":"2019-04-20 00:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/2019-04-19-lazy-loading-and-code-splitting-in-react-apps/index.md"}},{"id":"fc31b533-dfb5-52e8-88da-d3689bc52256","body":"\nMaintaining large React projects can be a difficult task. Below are a few practices I’ve adapted over the years working with React projects of all scales. A low of those practices were directly taken or inspired by excellent resources found in the React/Redux community, precisely:\n\n- [React: official documentation](https://react.dev/);\n- [Redux: official documentation](https://redux.js.org/);\n- [Ducks: Redux Reducer Bundles](https://github.com/erikras/ducks-modular-redux);\n- [Re-ducks: Building on the duck legacy](https://github.com/alexnm/re-ducks);\n- [React & Redux TypeScript guide](https://github.com/piotrwitek/react-redux-typescript-guide);\n\n**The proposed architecture is not meant to be enforced dogmatically and is a work in progress that might change over time.**\n\n## File structure\n\nDan Abramov created a [guide](https://react-file-structure.surge.sh/) for organizing files and he made a very good point. For months I’ve been following the “good” ways to organize React projects: starting at the separation of concerns with Presentational and Container components and finishing with adapting [ducks](https://github.com/erikras/ducks-modular-redux).\n\nIt worked well for small projects, but as they grew to be 30 different, unique screens and over 200 components, it became more difficult to maintain all of this together. At Milo, we came up with a directory structure that is inspired by Django and best practices from React, taking the separation of concerns to its extreme.\n\n```\nsrc/\n├── App.tsx\n├── index.ts\n├── store.ts\n├── types.ts\n├── shared/\n│    └── ComponentName.tsx\n├── modules/\n│    └── <moduleName>/\n│          ├── components/\n│          │     └── ComponentName.tsx\n│          ├── actionCreators.ts\n│          ├── actionTypes.ts\n│          ├── apiCalls.ts\n│          ├── operations.ts\n│          ├── selectors.ts\n│          ├── reducers.ts\n│          ├── utils.ts\n│          ├── types.ts\n│          └── index.ts\n└── screens/\n      ├── <screenNamespace>/\n      │     ├── SubcreenNameA.tsx\n      │     └── SubcreenNameB.tsx\n      └── Navigation.ts\n```\n\n### Shared\n\nThis contains the shared code used all across your app. It can include configuration files, primary presentational components (i.e. Buttons, Inputs, Grid, …) helpers to work with the API, and pretty much everything that doesn’t fit in other parts of the proposed architecture.\n\n### Screens\n\nScreens are components that are directly mounted on routes ([`react-router`](https://github.com/remix-run/react-router), [`react-navigation`](https://github.com/react-navigation/react-navigation)). They render shared and/or module components.\n\n### Modules\n\nSometimes, we need to share the logic between web (React) and mobile (React Native) apps. The proposed structure makes it very easy to reuse and maintain the code without influencing other app parts.\n\nThe main idea of `modules/` is to group a strongly coupled part of the application and make it as reusable as possible. It contains all the required components (later used in screens) as well as reducers, action creators, and other state-related utilities.\n\n- A module must contain the entire logic for handling its concept;\n- A module may contain all the required components to present its concept.\n\n#### Components\n\nWe don’t always follow the concept of a container and presentational components – the promoted thing with this concept is the separation of concerns which can be achieved in different, more maintainable ways, for example, through the Hooks API. Do what is more suitable for your case.\n\n> “I don’t suggest splitting your components like this anymore. If you find it natural in your codebase, this pattern can be handy. But I’ve seen it enforced without any necessity and with almost dogmatic fervor far too many times. The main reason I found it useful was because it let me separate complex stateful logic from other aspects of the component. Hooks let me do the same thing without an arbitrary division.” – [Dan Abramov](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)\n\n#### Index\n\nThe `index.ts` file should expose the public API of a module. Everything that is not exposed in this file should be considered private and never accessed from the outside.\n\n- The default export must be the reducer.\n- It must export `actions`, `operations`, `selectors`, and `types`.\n- It must expose all the components.\n\n```typescript\nimport * as actions from \"./actionCreators\";\nimport * as operations from \"./operations\";\nimport * as selectors from \"./selectors\";\nimport * as types from \"./types\";\nimport reducer from \"./reducers\";\n\n// Store/state-related stuff:\nexport default reducer;\nexport { actions, operations, selectors, types };\n\n// Components:\nexport { default as ComponentNameA } from \"./components/ComponentNameA\";\nexport { default as ComponentNameB } from \"./components/ComponentNameB\";\n```\n\n#### Action Types\n\nAction types are constants used by action creators and reducers. Each action type should be unique and prefixed by the project and module name.\n\n```typescript\nexport const POSTS_REQUEST = \"@@<project_name>/<module_name>/POSTS_REQUEST\";\nexport const POSTS_PROCESS = \"@@<project_name>/<module_name>/POSTS_PROCESS\";\n```\n\nYour action types should be pure string literals. Dynamic string operations (like template strings, string concatenation, etc.) will widen literal type to its supertype string. This will break contextual typing in reducer cases when using TypeScript or Flow.\n\n#### Action Creators\n\nThe action creators should follow the [Flow Standard Action](https://github.com/redux-utilities/flux-standard-action) specification when possible. Action shape should be predictable and known by the developers. Action creators should not contain any logic, nor transform the received payload – it makes them harder to test and the code is harder to debug.\n\n```typescript\nimport { createStandardAction } from \"typesafe-actions\";\nimport * as Types from \"./actionTypes\";\nimport { Payload } from \"./types\";\n\nexport const requestPosts =\n  createStandardAction(Types.POSTS_REQUEST)<void>();\n\nexport const processPosts =\n  createStandardAction(Types.POSTS_REQUEST)<Payload | Error>();\n```\n\nYou should not export any default value in `actionCreators.ts`. Using named exports, it is easier to map dispatch to all actions exposed by a module using [`bindActionCreators`](https://redux.js.org/api/bindactioncreators), as follows:\n\n```typescript\nimport { bindActionCreators } from \"redux\";\nimport * as Types from \"../../types\";\nimport { actions as moduleActionsA } from \"../moduleA\";\nimport { actions as moduleActionsB } from \"../moduleB\";\n\nconst mapDispatchToProps = (dispatch: Dispatch<Types.RootAction>) =>\n  bindActionCreators({ ...moduleActionsA, ...moduleActionsB }, dispatch);\n```\n\n#### API Calls\n\nAPI endpoints should not be hand-coded – it makes the code prone to errors and harder to maintain as API evolves. I encourage you to create a small configuration file with all available endpoints in `config.ts` file, then reuse those endpoints in `apiCalls.ts`.\n\n##### Configuration\n\n```typescript\nconst URL = \"\";\nconst API = \"\";\n\nexport default {\n  v1: {\n    posts: {\n      get(id: number, meta?: Object) {\n        return `${URL}${API}v1/posts/${id}${createQueryString(meta)}`;\n      },\n      list(meta?: Object) {\n        return `${URL}${API}v1/posts${createQueryString(meta)}`;\n      }\n    }\n  },\n\n  v2: { /* ... */ }\n};\n```\n\n##### API Calls\n\n```typescript\nexport const fetchPost = (id: number, meta: Object) =>\n  fetch(urls.v1.posts.get(id, meta))\n    .then(response => response.json());\n\nexport const fetchPosts = (meta: Object) =>\n  fetch(urls.v1.posts.list(meta))\n    .then(response => response.json());\n```\n\n#### Operations\n\nOperations can be [thunks](https://github.com/reduxjs/redux-thunk) or [sagas](https://redux-saga.js.org/) and everything else that delays the action dispatch. An operation is a function that can contain logic, dispatch multiple actions based on some predicates, and manipulate their payload.\n\n```typescript\nimport * as Types from \"../types\";\nimport * as actions from \"./actionCreators\";\nimport * as API from \"./apiCalls\";\n\nexport const doFooStuff = (payload: Object) =>\n  (dispatch: Dispatch<Types.RootAction>) => {\n    dispatch(actions.requestPosts());\n\n    API.fetchPosts(payload.meta)\n      .then(data => dispatch(actions.processPosts(normalizePosts(data))))\n      .catch(err => dispatch(actions.processPosts(err, true)));\n  };\n```\n\n#### Selectors\n\nSelectors can compute derived data, allowing Redux to store the minimal possible state. A selector is not recomputed unless one of its arguments changes. It minimized the amount of component re-renders to the minimum. Have a look at the excellent [reselect](https://github.com/reduxjs/reselect) package.\n\nConsider the following example – it renders a list of posts created by the currently logged-in user:\n\n```typescript\nclass PostsList extends React.PureComponent {\n  render() {\n    return (\n      <ul>\n        {\n          this.props.posts\n            .filter(post => post.author = this.props.userId)\n            .map(post => (\n              <div>\n                <p>{post.title}</p>\n                <p>{post.content}</p>\n              </div>\n            ))\n        }\n      </ul>\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  posts: state.posts.data,\n  userId: state.auth.user.id\n});\n```\n\nIn the example above, a render is triggered every time the post collection changes, even if the changed post is not created by the user. Using selectors, we can avoid those unnecessary re-renders and update the component only if one of the user’s posts has been created or modified:\n\n```typescript\n// selectors.ts\nimport { createSelector } from \"reselect\";\n\nconst postsSelector = state => state.posts.data;\nconst userSelector = state => state.auth.user;\nconst userPostsSelector = createSelector(\n  postsSelector,\n  userSelector,\n  (posts, user) => posts.filter(post => post.author === user.id)\n);\n```\n\n```typescript\n// PostsList.tsx\nclass PostsList extends React.PureComponent {\n  render() {\n    return (\n      <ul>\n        {this.props.userPosts.map(post => (\n          <div>\n            <p>{post.title}</p>\n            <p>{post.content}</p>\n          </div>\n        ))}\n      </ul>\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  userPosts: userPostsSelector(state)\n});\n```\n\nThe other thing about selectors is that they facilitate the work with a part of the application that was developed by somebody else – you don’t need to know the state’s shape to work with it if the exposed selectors are enough and well-documented.\n\n#### Reducers\n\nYou should export one reducer per module, but a module can be composed of multiple reducers. Don’t be afraid to break your reducer into multiple chunks to reduce complexity and make it easier to test. You can always combine them using [`combineReducers`](https://redux.js.org/api/combinereducers).\n\n```typescript\nimport { combineReducers } from \"redux\";\nimport { Action, PostsState, ErrorsState, LoadingState } from \"./types\";\nimport * as Types from \"./actionTypes\";\n\nexport const postsReducer = (state: PostsState = {}, action: Action) => {\n  switch (action.type) {\n    case Types.POSTS_PROCESS:\n      if (!action.error) return {...state, action.payload};\n\n    default:\n      return state;\n  }\n}\n\nexport const errorsReducer = (state: ErrorsState = null, action: Action) => {\n  switch (action.type) {\n    case Types.POSTS_PROCESS:\n      if (action.error) return action.payload;\n\n    default:\n      return state;\n  }\n}\n\nexport const loadingReducer = (state: LoadingState = false, action: Action) => {\n  switch (action.type) {\n    case Types.POSTS_REQUEST:\n      return true;\n    case Types.POSTS_PROCESS:\n      return false;\n    default:\n      return state;\n  }\n}\n\nexport default combineReducers({\n  data: postsReducer,\n  errors: errorsReducer,\n  loading: loadingReducer,\n});\n```\n\n#### Types\n\nIf you use Flow or TypeScript, it’s a good idea to keep all the types in one place (`types.ts`). By doing so, we can expose all of them at once to other modules of the app. This is particularly handy when we need to expose the root `Action` and `State` which is used in every selector and container. Here’s an example of `/types.ts`:\n\n```typescript\nimport { AnyAction } from \"redux\";\nimport { StateType } from \"typesafe-actions\";\nimport rootReducer from \"./reducers\";\nimport { types as FooTypes } from \"../../modules/foo\";\nimport { types as BarTypes } from \"../../modules/bar\";\n\nexport type RootState =\n  StateType<typeof rootReducer>;\n\nexport type RootAction =\n  FooTypes.Action | BarTypes.Action | AnyAction;\n```\n\n### Utilities for state management\n\nYou can think of Redux as a low-level API – it doesn’t force any particular patterns and allows you pretty much to do whatever you want.\n\n- [Ramda](https://ramdajs.com/): a practical functional library for JavaScript programmers.\n- [Immer](https://github.com/immerjs/immer): create the next immutable state by mutating the current one.\n\n### Utilities for creating styles\n\nCreating styles can be a pain, especially in React Native or when you need to create custom styles based on the state. [Styled Components](https://styled-components.com/ecosystem) can come in handy – they allow you to create styles directly in JavaScript using SCSS syntax.\n\n### Tips and tricks\n\n#### You can use reducers on the inner state\n\nCreating reducers to handle the inner component state is a good practice in the case when you have complex state logic – it is easier to test and in most cases, less error-prone. Creating reducers for inner state management is even easier with the new Hooks API.\n\n**Example:** from official React [`useReducer` example](https://react.dev/reference/react/useReducer):\n\n```jsx\nexport const initialState = { count: 0 };\n\nexport function reducer(state, action) {\n  switch (action.type) {\n    case \"increment\": return {count: state.count + 1};\n    case \"decrement\": return {count: state.count - 1};\n    default: throw new Error();\n  }\n}\n\nexport default function Counter({initialState}) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({type: \"increment\"})}>+</button>\n      <button onClick={() => dispatch({type: \"decrement\"})}>-</button>\n    </>\n  );\n}\n```\n\n### Do’s and don’ts\n\n#### Never render a list of children without assigning a unique key to each\n\nThis can have a huge impact on the performance, even bigger if you render a big list of elements. As from React documentation:\n\n> Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity. The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys.\n\n**Don’t:**\n\n```jsx\nclass FooComponent extends React.Component {\n  render() {\n    return this.props.data.map(item => <Item data={item} />);\n  }\n}\n\nclass FooComponent extends React.Component {\n  render() {\n    return this.props.data.map((item, index) => <Item key={index} data={item} />);\n  }\n}\n```\n\n**Do:**\n\n```jsx\nclass FooComponent extends React.Component {\n  render() {\n    return this.props.data.map(item => <Item key={item.id} data={item} />);\n  }\n}\n```\n\n#### Never create functions or objects in props\n\nThis can have a huge impact on the performance. If you create new objects or functions in the props, a new reference will be passed down to the child each time its parents re-render, resulting in unnecessary re-renders and probably more unwanted behaviors.\n\n**Don’t:**\n\n```jsx\nclass FooComponent extends React.Component {\n  render() {\n    return (\n      <FooChild\n        onClick={() => this.props.handleClick(...args)}\n        data={this.props.filter(item => item.id === 5)}\n      />\n    );\n  }\n}\n```\n\n**Do:**\n\n```jsx\nclass FooComponent extends React.Component {\n  onClick = (...args) => event => {\n    return this.props.handleClick(...args);\n  };\n\n  render() {\n    return (\n      <FooChild\n        onClick={this.onClick(...args)}\n        data={this.props.filteredData}\n      />\n    );\n  }\n}\n```\n\n#### Avoid duplicating data between props and state\n\nIf some data can be derived or calculated directly from the props, it’s unnecessary to replicate this data in the state. Props should be the only source of truth. In fact – if you want to calculate the state based on the received props, you’ll need to create a `componentDidUpdate` method and keep your state and props in sync – this is an anti-pattern.\n\nThe only case when assigning props to a state is acceptable is to pass initial data to a component that doesn’t need to be in sync with the store, e.g. forms.\n\n**Avoid:**\n\n```jsx\nclass FooComponent extends React.Component {\n  state = {\n    foo: this.props.foo,\n    bar: this.props.bar,\n  }\n}\n```\n\n#### Avoid overusing HOCs\n\nAs Michael Jackson (React-Router co-creator) said:\n\n> “Next time you think you need a HOC (higher-order component) in, you probably don’t. I can do anything you’re doing with your HOC using a regular component with a [render prop](https://legacy.reactjs.org/docs/render-props.html).“ – [Michael Jackson](https://twitter.com/mjackson/status/885910553432018945)\n\n#### Avoid using Components without `shouldComponentUpdate`\n\nA [`React.Component`](https://react.dev/reference/react/Component), when used without `shouldComponentUpdate`, will re-render on every prop and state change.\n\n1. Consider creating a `shouldComponentUpdate() `method to prevent unnecessary re-renders.\n2. Consider using the built-in `PureComponent` instead of writing `shouldComponentUpdate` by hand. `PureComponent` performs a shallow comparison of props and state, and reduces the chance that you’ll skip a necessary update.\n","excerpt":"Maintaining large React projects can be a difficult task. Below are a few practices I’ve adapted over the years working with React projects of all scales.…","tableOfContents":{"items":[{"url":"#file-structure","title":"File structure","items":[{"url":"#shared","title":"Shared"},{"url":"#screens","title":"Screens"},{"url":"#modules","title":"Modules"},{"url":"#utilities-for-state-management","title":"Utilities for state management"},{"url":"#utilities-for-creating-styles","title":"Utilities for creating styles"},{"url":"#tips-and-tricks","title":"Tips and tricks"},{"url":"#dos-and-donts","title":"Do’s and don’ts"}]}]},"fields":{"slug":"/blog/2019-03-01-enterprise-scale-react-redux-project-architecture/","timeToRead":{"minutes":11.775,"words":2355}},"frontmatter":{"title":"Enterprise-scale React & Redux project architecture","authors":["Bartosz Łaniewski"],"keywords":["React","Architecture"],"language":"en","description":null,"dateCreated":"February 28, 2019","dateCreatedMeta":"2019-03-01 00:00:00 +0100","dateUpdated":"December 16, 2023","dateUpdatedMeta":"2023-12-16 13:10:00 +0100","datePublished":"February 28, 2019","datePublishedMeta":"2019-03-01 00:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/2019-03-01-enterprise-scale-react-redux-project-architecture/index.md"}}]}},"staticQueryHashes":["1271460761","3216310583","991007626"],"slicesMap":{}}