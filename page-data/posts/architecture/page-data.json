{"componentChunkName":"component---src-templates-blog-posts-tsx","path":"/posts/architecture/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://laniewski.me"}}},"pageContext":{"keyword":"Architecture","data":[{"id":"c6992986-80bd-5979-82d7-6029c505265a","body":"\nWhen building React applications, we often create components meant to be used together – think of a `Select` and an `Option` or a `Tab` and a `TabContent`. Those components have a clear relationship — they share the same design language, logic, and state. They are bound together.\n\nLet’s examine the problem with “traditional” component APIs and see how to fix them using Compound Components.\n\n## Naive (traditional) approach\n\nBuilding shared components is more challenging than creating the application itself. They will be used by all developers in your company across multiple modules you’ve probably never seen. If the component API sucks, you’ll have a hard time refactoring it. How React component APIs are designed matters in the long term. Let’s see a few examples.\n\n### The Extensibility problem\n\nI bet you’ve probably seen a `Select` component with the following API:\n\n```jsx\n<Select\n  name=\"field\"\n  options={[\n    { value: 1, label: \"Option 1\" },\n    { value: 2, label: \"Option 2\" },\n  ]}\n  value={value}\n  onChange={setValue}\n/>\n```\n\nIt takes a `name` and a list of available `options` and renders a beautiful dropdown. Pretty neat!\n\nNow, imagine you have to implement a language selection and want to show a flag near each language. We can modify the source code of the `Select` component to accept an optional `image` property and render it conditionally:\n\n```jsx {4-5}\n<Select\n  name=\"language\"\n  options={[\n    { value: \"pl\", label: \"Polish\", image: \"pl.png\" },\n    { value: \"fr\", label: \"French\", image: \"fr.png\" },\n  ]}\n  value={value}\n  onChange={setValue}\n/>\n```\n\nTimes fly, and so do design trends. There’s a new language to be added. Designers provided an SVG flag (as it scales better on retina displays) and want you to show a “New” badge near the value. We can add some new fields:\n\n```jsx {4}\n<Select\n  name=\"language\"\n  options={[\n    { value: \"it\", label: \"Italian\", icon: <ItalianFlag />, badge: <Badge>New</Badge> },\n    { value: \"pl\", label: \"Polish\", image: \"pl.png\" },\n    { value: \"fr\", label: \"French\", image: \"fr.png\" },\n  ]}\n  value={value}\n  onChange={setValue}\n/>\n```\n\n...but you see where this is going, right? Instead of leveraging composition, we have to modify the source code of the `Select` component each time a field needs stylistic customization.\n\nWhat if, instead of adding more and more properties, we could use the parent-child relationship? Think of:\n\n```jsx\n<Select name=\"language\" value={value} onChange={setValue}>\n  <Select.Option value=\"it\">\n    <ItalianFlag />\n    <Select.OptionLabel>Italian <Badge>New</Badge></Select.OptionLabel>\n  </Select.Option>\n\n  <Select.Option value=\"pl\">\n    <Image src=\"pl.png\" />\n    <Select.OptionLabel>Polish</Select.OptionLabel>\n  </Select.Option>\n\n  <Select.Option value=\"fr\">\n    <Image src=\"fr.png\" />\n    <Select.OptionLabel>French</Select.OptionLabel>\n  </Select.Option>\n</Select>\n```\n\n`Select` does not need to know anything about its children; it will render whatever we give it. We can render any component inside the `Select` without modifying the source code!\n\n```jsx\n<Select name=\"language\" value={value} onChange={setValue}>\n  <Heading>Europe</Heading>\n  <Select.Option value=\"...\">...</Select.Option>\n  <Select.Option value=\"...\">...</Select.Option>\n\n  <Divider />\n\n  <Heading>Asia</Heading>\n  <Select.Option value=\"...\">...</Select.Option>\n  <Select.Option value=\"...\">...</Select.Option>\n</Select>\n```\n\nThat approach makes the component more customizable and thus easier to maintain in the long term. In fact, with that API, we can render whatever and whenever we want. The `Select` component delegates this responsibility to you. This is called _Inversion of Control_.\n\n### The State Management problem\n\nLet's go a little bit further. Everybody knows state management is hard, and you should not do it unless you have to. What if instead of handling the component's state each time:\n\n```jsx\n<Tabs>\n  <Tabs.List>\n    <Tabs.Tab isActive={activeTabIndex === 0} onClick={() => setActiveTabIndex(0)}>Tab 1</Tabs.Tab>\n    <Tabs.Tab isActive={activeTabIndex === 1} onClick={() => setActiveTabIndex(1)}>Tab 2</Tabs.Tab>\n  <Tabs.List>\n\n  <Tabs.Content>\n    <Tabs.Panel isVisible={activeTabIndex === 0}>Content for Tab 1</Tabs.Panel>\n    <Tabs.Panel isVisible={activeTabIndex === 1}>Content for Tab 2</Tabs.Panel>\n  </Tabs.Content>\n</Tabs>\n```\n\n...the components could handle their state independently:\n\n```jsx\n<Tabs initialActiveTab={0}>\n  <Tabs.List>\n    <Tabs.Tab>Tab 1</Tabs.Tab>\n    <Tabs.Tab>Tab 2</Tabs.Tab>\n  <Tabs.List>\n\n  <Tabs.Content>\n    <Tabs.Panel>Content for Tab 1</Tabs.Panel>\n    <Tabs.Panel>Content for Tab 2</Tabs.Panel>\n  </Tabs.Content>\n</Tabs>\n```\n\n...unless we want to take the wheel:\n\n```jsx\n<Tabs activeTab={activeTabIndex} onActiveTabChange={setActiveTabIndex}>\n  <Tabs.List>\n    <Tabs.Tab>Tab 1</Tabs.Tab>\n    <Tabs.Tab>Tab 2</Tabs.Tab>\n  <Tabs.List>\n\n  <Tabs.Content>\n    <Tabs.Panel>Content for Tab 1</Tabs.Panel>\n    <Tabs.Panel>Content for Tab 2</Tabs.Panel>\n  </Tabs.Content>\n</Tabs>\n```\n\nThat would be awesome, no? With this approach, we could not only render whatever we want, whenever we want, but also not have to worry about state management!\n\n## Compound components to the rescue\n\n“Compound Components” is a React pattern where several components implicitly share a state and leverage the parent-child relationship to communicate via the [Context API](https://react.dev/learn/passing-data-deeply-with-context) in the background.\n\n### How to create a Compound Component?\n\nFirst, let’s start by creating a context that will handle all of the component’s state:\n\n```jsx\nconst TabsContext = createContext({});\n\nexport function Tabs({ children, initialActiveTab = 0 }) {\n  const [activeTab, onActiveTabChange] = useState(initialActiveTab);\n\n  const context = useMemo(\n    () => ({\n      activeTab,\n      onActiveTabChange,\n    }),\n    [activeTab]\n  );\n\n  return (\n    <TabsContext.Provider value={context}>{children}</TabsContext.Provider>\n  );\n}\n```\n\nThe `Tabs` component defines its state and makes it available to its children via the context. This will allow us to do state management in the background without worrying about prop drilling.\n\nThen, let’s create two components:\n- `Tabs.Tab`, which will render a button to switch the current tab:\n\n    ```jsx\n    Tabs.Tab = function TabsTab({ children, isActive, onClick }) {\n      return <button onClick={onClick}>{children}</button>;\n    };\n    ```\n\n- `Tabs.Panel`, which will render the content if the tab is selected:\n\n    ```jsx\n    Tabs.Panel = function TabsPanel({ children, isVisible }) {\n      return isVisible ? children : null;\n    };\n    ```\n\nTo glue all the components together, let’s create `Tabs.List` and `Tabs.Content` components. Those components will read from the context and populate their children with properties.\n\n```tsx\nTabs.List = function TabsList({ children }) {\n  const { activeTab, onActiveTabChange } = useContext(TabsContext);\n\n  return React.Children.map(children, (child, index) => (\n    React.cloneElement(child, {\n      isActive: activeTab === index,\n      onClick: () => onActiveTabChange(index),\n    })\n  ));\n};\n\nTabs.Content = function TabsContent({ children }) {\n  const { activeTab } = useContext(TabsContext);\n\n  return React.Children.map(children, (child, index) => (\n    React.cloneElement(child, {\n      isVisible: activeTab === index,\n    })\n  ));\n};\n```\n\nAs you can see, both components iterate over their children and clone them to provide additional properties from the context to fulfill the children’s interfaces.\n\n### How to make a Compound Component controlled?\n\nOur `Tabs` component is [uncontrolled](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components); it manages its state on its own. We can extend it to become controlled.\n\nLet’s start by writing a helper hook that will help us manage the state in a safe manner for both controlled and uncontrolled components:\n\n```js\nfunction useControlled({ value, initialValue }) {\n  const { current: isUncontrolled } = useRef(value === undefined);\n\n  const [localValue, setLocalValue] = useState(initialValue);\n\n  const safeValue = isUncontrolled ? localValue : value;\n  const safeSetValue = useCallback((newValue) => {\n    if (isUncontrolled) {\n      setLocalValue(newValue);\n    }\n  }, []);\n\n  return [safeValue, safeSetValue];\n}\n```\n\nNow, we can use this hook as follows to make our `Tabs` a controlled or uncontrolled component at will:\n\n```jsx {6-7, 9-12, 14-17, 19-25}\nconst TabsContext = createContext({});\n\nexport function Tabs({\n  children,\n  initialActiveTab = 0,\n  activeTab,\n  onActiveTabChange\n}) {\n  const [value, onValueChange] = useControlled({\n    value: activeTab,\n    initialValue: initialActiveTab\n  });\n\n  const handleValueChange = useCallback((newValue) => {\n    onValueChange(newValue);\n    onActiveTabChange?.(newValue);\n  }, [onValueChange, onActiveTabChange]);\n\n  const context = useMemo(\n    () => ({\n      activeTab: value,\n      onActiveTabChange: handleValueChange,\n    }),\n    [value, handleValueChange]\n  );\n\n  return (\n    <TabsContext.Provider value={context}>{children}</TabsContext.Provider>\n  );\n}\n```\n\n## Conclusion\n\nCompound Components allow you to create composable components with straightforward and simple-to-use API. By leveraging the Context API and the parent-child relationship, we avoided prop drilling and made the state sharing implicit while giving the developer control over what is being rendered.\n","excerpt":"When building React applications, we often create components meant to be used together – think of a Select and an Option or a Tab and a TabContent. Those…","tableOfContents":{"items":[{"url":"#naive-traditional-approach","title":"Naive (traditional) approach","items":[{"url":"#the-extensibility-problem","title":"The Extensibility problem"},{"url":"#the-state-management-problem","title":"The State Management problem"}]},{"url":"#compound-components-to-the-rescue","title":"Compound components to the rescue","items":[{"url":"#how-to-create-a-compound-component","title":"How to create a Compound Component?"},{"url":"#how-to-make-a-compound-component-controlled","title":"How to make a Compound Component controlled?"}]},{"url":"#conclusion","title":"Conclusion"}]},"fields":{"slug":"/blog/compound-components-in-react/","timeToRead":{"minutes":5.87,"words":1174}},"frontmatter":{"title":"How to write better React with Compound Components?","authors":["Bartosz Łaniewski"],"keywords":["React","Architecture"],"language":"en","description":null,"dateCreated":"April 07, 2024","dateCreatedMeta":"2024-04-07 12:00:00 +0100","dateUpdated":"April 22, 2024","dateUpdatedMeta":"2024-04-22 15:00:00 +0100","datePublished":"April 22, 2024","datePublishedMeta":"2024-04-22 15:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/compound-components-in-react/index.md"}},{"id":"b5bffd9c-b881-59b9-9dd2-4f093bc69ba1","body":"\nBarrel files consolidate the exports of multiple modules into a single file. We use them to import a module using a single import statement without worrying about the underlying folder structure.\n\nHave a look at the following example of a `Modal` component:\n\n```\n/components\n└── /Modal\n    ├── Modal.js\n    ├── ModalHeader.js\n    ├── ModalContent.js\n    └── ModalFooter.js\n```\n\nA barrel would be an `index.js` file at `./components/Modal` with the following definition:\n\n```js\nexport { Modal } from \"./Modal\";\nexport { ModalHeader } from \"./ModalHeader\";\nexport { ModalContent } from \"./ModalContent\";\nexport { ModalFooter } from \"./ModalFooter\";\n```\n\nIt allows us to write a single import statement, such as:\n\n```js\nimport { Modal, ModalHeader, ModalContent, ModalFooter } from \"./Modal\";\n```\n\n…instead of:\n\n```js\nimport { Modal } from \"./Modal/Modal\";\nimport { ModalHeader } from \"./Modal/ModalHeader\";\nimport { ModalContent } from \"./Modal/ModalContent\";\nimport { ModalFooter } from \"./Modal/ModalFooter\";\n```\n\nAt first glance, barrel files look promising! Barrel files can improve code organization and make imports cleaner, especially in larger projects with many modules. But there’s a hidden cost.\n\n## The bundle size cost\n\nIf you target a no-build architecture or don’t have [tree-shaking](/blog/2018-04-29-publishing-packages-to-npm/) enabled in your bundler, all the files imported in the barrel file will get bundled into the application, even when unused! It results in tons of dead code, which can impact loading times.\n\nLet’s have a look at the following application, which renders a simple `Button` component from the [Material Design component library](https://mui.com/material-ui/):\n\n```jsx\nimport { Button } from \"@mui/material\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\n> node scripts/build.js\n\nCreating an optimized production build...\nCompiled successfully.\n\nFile sizes after gzip:\n\n  151.47 kB build/static/js/main.js\n```\n\nNow let’s import the `Button` component directly, skipping the barrel file:\n\n```diff\n-import { Button } from \"@mui/material\";\n+import Button from \"@mui/material/Button\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\n> node scripts/build.js\n\nCreating an optimized production build...\nCompiled successfully.\n\nFile sizes after gzip:\n\n  75.69 kB (-75.77 kB)  build/static/js/main.js\n```\n\n<Alert type=\"success\">\n  When not using a barrel file, the build size <u>decreased from ~151 kB to ~75 kB</u>.\n</Alert>\n\n<Alert type=\"info\">\n  Fortunately, most bundlers have tree shaking enabled by default because it reduces bundle size without changing the code behavior.\n</Alert>\n\n## The build-time cost\n\nBarrel files are one of the key reasons why tooling is slow in bigger projects. All of your modules are likely to load barrel files (the imports are nice, after all), and so are your modules hidden behind the barrel files. It can result in a graph of import statements, where each module depends on another one, and so on.\n\nThe more files, the longer it takes for the bundler to resolve and manage them. Here are the execution times of the build script for both variants:\n\n- **With barrel file:**\n\n```jsx\nimport { Button } from \"@mui/material\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\nExecution time: 0h:00m:10s sec\n```\n\n- **Without barrel file:**\n\n```diff\n-import { Button } from \"@mui/material\";\n+import Button from \"@mui/material/Button\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\nExecution time: 0h:00m:7s sec\n```\n\n<Alert type=\"success\">\n  The build time is <u>30% faster</u> when not using a barrel file.<sup title=\"In a real-world scenario, the build time will probably not decrease by that much.\">*</sup>\n</Alert>\n\n## The test-time cost\n\nIn both articles (I highly recommend reading those):\n\n- [\"Why is My Jest Test Suite So Slow?\"](https://dev.to/twynsicle/why-is-my-jest-test-suite-so-slow-1od) by Steven Lemon, and\n- [\"Speeding up the JavaScript ecosystem - The barrel file debacle\"](https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7/) by Marvin Hagemeister\n\n...the conclusion is the same: barrel files slow down tests.\n\n> The problem is that Jest has no idea where the component we’re importing is located. The barrel file has intentionally obfuscated that fact. So when Jest hits a barrel file, it must load every export referenced inside it. This behavior quickly gets out of hand for large libraries like `@mui/material`. We’re looking for a single button and end up loading hundreds of additional files. – Steven Lemon in [\"Why is My Jest Test Suite So Slow?\"](https://dev.to/twynsicle/why-is-my-jest-test-suite-so-slow-1od)\n\nLet's run the same test suite on two modules:\n\n- **Importing from barrel file:**\n\n```jsx\nimport { Button } from \"@mui/material\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\n> node scripts/test.js\n\n PASS  src/App.test.js\n  ✓ renders button (25 ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nTime:        1.717 s, estimated 2 s\n```\n\n- **Importing directly from the module:**\n\n```diff\n-import { Button } from \"@mui/material\";\n+import Button from \"@mui/material/Button\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\n> node scripts/test.js\n\n PASS  src/App.test.js\n  ✓ renders button (29 ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nTime:        1.097 s\n```\n\n<Alert type=\"success\">\n  The test duration <u>decreased from ~1.7 to ~1.1 seconds</u> when not importing from a barrel file.\n</Alert>\n\nNotice the test suite itself took 25-29ms. The 600ms overhead comes from building the module graph. The cost of loading modules can change depending on the machine and the tooling.\n\nIn my lab setup, 10 independent tests running in 4 child processes would result in a $$\\frac{0.6 \\times 10}{4} = 1.5$$ seconds overhead.\n\n## The lint-time cost\n\nBarrel files affect the linting performance. Let’s say you use the `import/no-cycle` rule from `eslint-plugin-import`, which ensures there is no resolvable path back to a module via its dependencies by building a dependency graph. When it comes across a barrel file, the linting time will take longer because it has to resolve all the exports from the barrel file.\n\n<Alert type=\"info\">\n  Unlike testing, linting is done on a file basis, so the dependency graph is built for each file separately.\n</Alert>\n\n## Developer experience\n\n1. Most (if not all) IDEs have autocomplete and IntelliSense - you can type the function name, and it will get the import right automatically.\n\n2. Having barrel files makes code navigation harder - <kbd>CMD + click</kbd> navigates to the barrel file instead of the actual definition of the module.\n\n## Conclusion\n\nAs software engineers, we are implementing new features daily, and each one has to be covered by _tests_. To do so, we use _linters_ to help us write better code faster. Then, we _build_ our app for a testing environment before releasing it to production (_another build_), and so on...\n\nBuilds, tests, and tooling will only get slower as the application grows. Avoiding barrel files can improve performance without compromising the architecture or the developer experience.\n","excerpt":"Barrel files consolidate the exports of multiple modules into a single file. We use them to import a module using a single import statement without…","tableOfContents":{"items":[{"url":"#the-bundle-size-cost","title":"The bundle size cost"},{"url":"#the-build-time-cost","title":"The build-time cost"},{"url":"#the-test-time-cost","title":"The test-time cost"},{"url":"#the-lint-time-cost","title":"The lint-time cost"},{"url":"#developer-experience","title":"Developer experience"},{"url":"#conclusion","title":"Conclusion"}]},"fields":{"slug":"/blog/pitfalls-of-barrel-files-in-javascript-modules/","timeToRead":{"minutes":5.32,"words":1064}},"frontmatter":{"title":"Why you should avoid Barrel Files in JavaScript Modules?","authors":["Bartosz Łaniewski"],"keywords":["JavaScript","Architecture"],"language":"en","description":null,"dateCreated":"March 27, 2024","dateCreatedMeta":"2024-03-28 00:00:00 +0100","dateUpdated":"April 05, 2024","dateUpdatedMeta":"2024-04-05 14:30:00 +0100","datePublished":"April 05, 2024","datePublishedMeta":"2024-04-05 14:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/pitfalls-of-barrel-files-in-javascript-modules/index.md"}},{"id":"fc31b533-dfb5-52e8-88da-d3689bc52256","body":"\nMaintaining large React projects can be a difficult task. Below are a few practices I’ve adapted over the years working with React projects of all scales. A low of those practices were directly taken or inspired by excellent resources found in the React/Redux community, precisely:\n\n- [React: official documentation](https://react.dev/);\n- [Redux: official documentation](https://redux.js.org/);\n- [Ducks: Redux Reducer Bundles](https://github.com/erikras/ducks-modular-redux);\n- [Re-ducks: Building on the duck legacy](https://github.com/alexnm/re-ducks);\n- [React & Redux TypeScript guide](https://github.com/piotrwitek/react-redux-typescript-guide);\n\n**The proposed architecture is not meant to be enforced dogmatically and is a work in progress that might change over time.**\n\n## File structure\n\nDan Abramov created a [guide](https://react-file-structure.surge.sh/) for organizing files and he made a very good point. For months I’ve been following the “good” ways to organize React projects: starting at the separation of concerns with Presentational and Container components and finishing with adapting [ducks](https://github.com/erikras/ducks-modular-redux).\n\nIt worked well for small projects, but as they grew to be 30 different, unique screens and over 200 components, it became more difficult to maintain all of this together. At Milo, we came up with a directory structure that is inspired by Django and best practices from React, taking the separation of concerns to its extreme.\n\n```\nsrc/\n├── App.tsx\n├── index.ts\n├── store.ts\n├── types.ts\n├── shared/\n│    └── ComponentName.tsx\n├── modules/\n│    └── <moduleName>/\n│          ├── components/\n│          │     └── ComponentName.tsx\n│          ├── actionCreators.ts\n│          ├── actionTypes.ts\n│          ├── apiCalls.ts\n│          ├── operations.ts\n│          ├── selectors.ts\n│          ├── reducers.ts\n│          ├── utils.ts\n│          ├── types.ts\n│          └── index.ts\n└── screens/\n      ├── <screenNamespace>/\n      │     ├── SubcreenNameA.tsx\n      │     └── SubcreenNameB.tsx\n      └── Navigation.ts\n```\n\n### Shared\n\nThis contains the shared code used all across your app. It can include configuration files, primary presentational components (i.e. Buttons, Inputs, Grid, …) helpers to work with the API, and pretty much everything that doesn’t fit in other parts of the proposed architecture.\n\n### Screens\n\nScreens are components that are directly mounted on routes ([`react-router`](https://github.com/remix-run/react-router), [`react-navigation`](https://github.com/react-navigation/react-navigation)). They render shared and/or module components.\n\n### Modules\n\nSometimes, we need to share the logic between web (React) and mobile (React Native) apps. The proposed structure makes it very easy to reuse and maintain the code without influencing other app parts.\n\nThe main idea of `modules/` is to group a strongly coupled part of the application and make it as reusable as possible. It contains all the required components (later used in screens) as well as reducers, action creators, and other state-related utilities.\n\n- A module must contain the entire logic for handling its concept;\n- A module may contain all the required components to present its concept.\n\n#### Components\n\nWe don’t always follow the concept of a container and presentational components – the promoted thing with this concept is the separation of concerns which can be achieved in different, more maintainable ways, for example, through the Hooks API. Do what is more suitable for your case.\n\n> “I don’t suggest splitting your components like this anymore. If you find it natural in your codebase, this pattern can be handy. But I’ve seen it enforced without any necessity and with almost dogmatic fervor far too many times. The main reason I found it useful was because it let me separate complex stateful logic from other aspects of the component. Hooks let me do the same thing without an arbitrary division.” – [Dan Abramov](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)\n\n#### Index\n\nThe `index.ts` file should expose the public API of a module. Everything that is not exposed in this file should be considered private and never accessed from the outside.\n\n- The default export must be the reducer.\n- It must export `actions`, `operations`, `selectors`, and `types`.\n- It must expose all the components.\n\n```typescript\nimport * as actions from \"./actionCreators\";\nimport * as operations from \"./operations\";\nimport * as selectors from \"./selectors\";\nimport * as types from \"./types\";\nimport reducer from \"./reducers\";\n\n// Store/state-related stuff:\nexport default reducer;\nexport { actions, operations, selectors, types };\n\n// Components:\nexport { default as ComponentNameA } from \"./components/ComponentNameA\";\nexport { default as ComponentNameB } from \"./components/ComponentNameB\";\n```\n\n#### Action Types\n\nAction types are constants used by action creators and reducers. Each action type should be unique and prefixed by the project and module name.\n\n```typescript\nexport const POSTS_REQUEST = \"@@<project_name>/<module_name>/POSTS_REQUEST\";\nexport const POSTS_PROCESS = \"@@<project_name>/<module_name>/POSTS_PROCESS\";\n```\n\nYour action types should be pure string literals. Dynamic string operations (like template strings, string concatenation, etc.) will widen literal type to its supertype string. This will break contextual typing in reducer cases when using TypeScript or Flow.\n\n#### Action Creators\n\nThe action creators should follow the [Flow Standard Action](https://github.com/redux-utilities/flux-standard-action) specification when possible. Action shape should be predictable and known by the developers. Action creators should not contain any logic, nor transform the received payload – it makes them harder to test and the code is harder to debug.\n\n```typescript\nimport { createStandardAction } from \"typesafe-actions\";\nimport * as Types from \"./actionTypes\";\nimport { Payload } from \"./types\";\n\nexport const requestPosts =\n  createStandardAction(Types.POSTS_REQUEST)<void>();\n\nexport const processPosts =\n  createStandardAction(Types.POSTS_REQUEST)<Payload | Error>();\n```\n\nYou should not export any default value in `actionCreators.ts`. Using named exports, it is easier to map dispatch to all actions exposed by a module using [`bindActionCreators`](https://redux.js.org/api/bindactioncreators), as follows:\n\n```typescript\nimport { bindActionCreators } from \"redux\";\nimport * as Types from \"../../types\";\nimport { actions as moduleActionsA } from \"../moduleA\";\nimport { actions as moduleActionsB } from \"../moduleB\";\n\nconst mapDispatchToProps = (dispatch: Dispatch<Types.RootAction>) =>\n  bindActionCreators({ ...moduleActionsA, ...moduleActionsB }, dispatch);\n```\n\n<Newsletter />\n\n#### API Calls\n\nAPI endpoints should not be hand-coded – it makes the code prone to errors and harder to maintain as API evolves. I encourage you to create a small configuration file with all available endpoints in `config.ts` file, then reuse those endpoints in `apiCalls.ts`.\n\n##### Configuration\n\n```typescript\nconst URL = \"\";\nconst API = \"\";\n\nexport default {\n  v1: {\n    posts: {\n      get(id: number, meta?: Object) {\n        return `${URL}${API}v1/posts/${id}${createQueryString(meta)}`;\n      },\n      list(meta?: Object) {\n        return `${URL}${API}v1/posts${createQueryString(meta)}`;\n      }\n    }\n  },\n\n  v2: { /* ... */ }\n};\n```\n\n##### API Calls\n\n```typescript\nexport const fetchPost = (id: number, meta: Object) =>\n  fetch(urls.v1.posts.get(id, meta))\n    .then(response => response.json());\n\nexport const fetchPosts = (meta: Object) =>\n  fetch(urls.v1.posts.list(meta))\n    .then(response => response.json());\n```\n\n#### Operations\n\nOperations can be [thunks](https://github.com/reduxjs/redux-thunk) or [sagas](https://redux-saga.js.org/) and everything else that delays the action dispatch. An operation is a function that can contain logic, dispatch multiple actions based on some predicates, and manipulate their payload.\n\n```typescript\nimport * as Types from \"../types\";\nimport * as actions from \"./actionCreators\";\nimport * as API from \"./apiCalls\";\n\nexport const doFooStuff = (payload: Object) =>\n  (dispatch: Dispatch<Types.RootAction>) => {\n    dispatch(actions.requestPosts());\n\n    API.fetchPosts(payload.meta)\n      .then(data => dispatch(actions.processPosts(normalizePosts(data))))\n      .catch(err => dispatch(actions.processPosts(err, true)));\n  };\n```\n\n#### Selectors\n\nSelectors can compute derived data, allowing Redux to store the minimal possible state. A selector is not recomputed unless one of its arguments changes. It minimized the amount of component re-renders to the minimum. Have a look at the excellent [reselect](https://github.com/reduxjs/reselect) package.\n\nConsider the following example – it renders a list of posts created by the currently logged-in user:\n\n```typescript\nclass PostsList extends React.PureComponent {\n  render() {\n    return (\n      <ul>\n        {\n          this.props.posts\n            .filter(post => post.author = this.props.userId)\n            .map(post => (\n              <div>\n                <p>{post.title}</p>\n                <p>{post.content}</p>\n              </div>\n            ))\n        }\n      </ul>\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  posts: state.posts.data,\n  userId: state.auth.user.id\n});\n```\n\nIn the example above, a render is triggered every time the post collection changes, even if the changed post is not created by the user. Using selectors, we can avoid those unnecessary re-renders and update the component only if one of the user’s posts has been created or modified:\n\n```typescript\n// selectors.ts\nimport { createSelector } from \"reselect\";\n\nconst postsSelector = state => state.posts.data;\nconst userSelector = state => state.auth.user;\nconst userPostsSelector = createSelector(\n  postsSelector,\n  userSelector,\n  (posts, user) => posts.filter(post => post.author === user.id)\n);\n```\n\n```typescript\n// PostsList.tsx\nclass PostsList extends React.PureComponent {\n  render() {\n    return (\n      <ul>\n        {this.props.userPosts.map(post => (\n          <div>\n            <p>{post.title}</p>\n            <p>{post.content}</p>\n          </div>\n        ))}\n      </ul>\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  userPosts: userPostsSelector(state)\n});\n```\n\nThe other thing about selectors is that they facilitate the work with a part of the application that was developed by somebody else – you don’t need to know the state’s shape to work with it if the exposed selectors are enough and well-documented.\n\n#### Reducers\n\nYou should export one reducer per module, but a module can be composed of multiple reducers. Don’t be afraid to break your reducer into multiple chunks to reduce complexity and make it easier to test. You can always combine them using [`combineReducers`](https://redux.js.org/api/combinereducers).\n\n```typescript\nimport { combineReducers } from \"redux\";\nimport { Action, PostsState, ErrorsState, LoadingState } from \"./types\";\nimport * as Types from \"./actionTypes\";\n\nexport const postsReducer = (state: PostsState = {}, action: Action) => {\n  switch (action.type) {\n    case Types.POSTS_PROCESS:\n      if (!action.error) return {...state, action.payload};\n\n    default:\n      return state;\n  }\n}\n\nexport const errorsReducer = (state: ErrorsState = null, action: Action) => {\n  switch (action.type) {\n    case Types.POSTS_PROCESS:\n      if (action.error) return action.payload;\n\n    default:\n      return state;\n  }\n}\n\nexport const loadingReducer = (state: LoadingState = false, action: Action) => {\n  switch (action.type) {\n    case Types.POSTS_REQUEST:\n      return true;\n    case Types.POSTS_PROCESS:\n      return false;\n    default:\n      return state;\n  }\n}\n\nexport default combineReducers({\n  data: postsReducer,\n  errors: errorsReducer,\n  loading: loadingReducer,\n});\n```\n\n#### Types\n\nIf you use Flow or TypeScript, it’s a good idea to keep all the types in one place (`types.ts`). By doing so, we can expose all of them at once to other modules of the app. This is particularly handy when we need to expose the root `Action` and `State` which is used in every selector and container. Here’s an example of `/types.ts`:\n\n```typescript\nimport { AnyAction } from \"redux\";\nimport { StateType } from \"typesafe-actions\";\nimport rootReducer from \"./reducers\";\nimport { types as FooTypes } from \"../../modules/foo\";\nimport { types as BarTypes } from \"../../modules/bar\";\n\nexport type RootState =\n  StateType<typeof rootReducer>;\n\nexport type RootAction =\n  FooTypes.Action | BarTypes.Action | AnyAction;\n```\n\n### Utilities for state management\n\nYou can think of Redux as a low-level API – it doesn’t force any particular patterns and allows you pretty much to do whatever you want.\n\n- [Ramda](https://ramdajs.com/): a practical functional library for JavaScript programmers.\n- [Immer](https://github.com/immerjs/immer): create the next immutable state by mutating the current one.\n\n### Utilities for creating styles\n\nCreating styles can be a pain, especially in React Native or when you need to create custom styles based on the state. [Styled Components](https://styled-components.com/ecosystem) can come in handy – they allow you to create styles directly in JavaScript using SCSS syntax.\n\n### Tips and tricks\n\n#### You can use reducers on the inner state\n\nCreating reducers to handle the inner component state is a good practice in the case when you have complex state logic – it is easier to test and in most cases, less error-prone. Creating reducers for inner state management is even easier with the new Hooks API.\n\n**Example:** from official React [`useReducer` example](https://react.dev/reference/react/useReducer):\n\n```jsx\nexport const initialState = { count: 0 };\n\nexport function reducer(state, action) {\n  switch (action.type) {\n    case \"increment\": return {count: state.count + 1};\n    case \"decrement\": return {count: state.count - 1};\n    default: throw new Error();\n  }\n}\n\nexport default function Counter({initialState}) {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({type: \"increment\"})}>+</button>\n      <button onClick={() => dispatch({type: \"decrement\"})}>-</button>\n    </>\n  );\n}\n```\n\n### Do’s and don’ts\n\n#### Never render a list of children without assigning a unique key to each\n\nThis can have a huge impact on the performance, even bigger if you render a big list of elements. As from React documentation:\n\n> Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity. The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys.\n\n**Don’t:**\n\n```jsx\nclass FooComponent extends React.Component {\n  render() {\n    return this.props.data.map(item => <Item data={item} />);\n  }\n}\n\nclass FooComponent extends React.Component {\n  render() {\n    return this.props.data.map((item, index) => <Item key={index} data={item} />);\n  }\n}\n```\n\n**Do:**\n\n```jsx\nclass FooComponent extends React.Component {\n  render() {\n    return this.props.data.map(item => <Item key={item.id} data={item} />);\n  }\n}\n```\n\n#### Never create functions or objects in props\n\nThis can have a huge impact on the performance. If you create new objects or functions in the props, a new reference will be passed down to the child each time its parents re-render, resulting in unnecessary re-renders and probably more unwanted behaviors.\n\n**Don’t:**\n\n```jsx\nclass FooComponent extends React.Component {\n  render() {\n    return (\n      <FooChild\n        onClick={() => this.props.handleClick(...args)}\n        data={this.props.filter(item => item.id === 5)}\n      />\n    );\n  }\n}\n```\n\n**Do:**\n\n```jsx\nclass FooComponent extends React.Component {\n  onClick = (...args) => event => {\n    return this.props.handleClick(...args);\n  };\n\n  render() {\n    return (\n      <FooChild\n        onClick={this.onClick(...args)}\n        data={this.props.filteredData}\n      />\n    );\n  }\n}\n```\n\n#### Avoid duplicating data between props and state\n\nIf some data can be derived or calculated directly from the props, it’s unnecessary to replicate this data in the state. Props should be the only source of truth. In fact – if you want to calculate the state based on the received props, you’ll need to create a `componentDidUpdate` method and keep your state and props in sync – this is an anti-pattern.\n\nThe only case when assigning props to a state is acceptable is to pass initial data to a component that doesn’t need to be in sync with the store, e.g. forms.\n\n**Avoid:**\n\n```jsx\nclass FooComponent extends React.Component {\n  state = {\n    foo: this.props.foo,\n    bar: this.props.bar,\n  }\n}\n```\n\n#### Avoid overusing HOCs\n\nAs Michael Jackson (React-Router co-creator) said:\n\n> “Next time you think you need a HOC (higher-order component) in, you probably don’t. I can do anything you’re doing with your HOC using a regular component with a [render prop](https://legacy.reactjs.org/docs/render-props.html).“ – [Michael Jackson](https://twitter.com/mjackson/status/885910553432018945)\n\n#### Avoid using Components without `shouldComponentUpdate`\n\nA [`React.Component`](https://react.dev/reference/react/Component), when used without `shouldComponentUpdate`, will re-render on every prop and state change.\n\n1. Consider creating a `shouldComponentUpdate() `method to prevent unnecessary re-renders.\n2. Consider using the built-in `PureComponent` instead of writing `shouldComponentUpdate` by hand. `PureComponent` performs a shallow comparison of props and state, and reduces the chance that you’ll skip a necessary update.\n","excerpt":"Maintaining large React projects can be a difficult task. Below are a few practices I’ve adapted over the years working with React projects of all scales.…","tableOfContents":{"items":[{"url":"#file-structure","title":"File structure","items":[{"url":"#shared","title":"Shared"},{"url":"#screens","title":"Screens"},{"url":"#modules","title":"Modules"},{"url":"#utilities-for-state-management","title":"Utilities for state management"},{"url":"#utilities-for-creating-styles","title":"Utilities for creating styles"},{"url":"#tips-and-tricks","title":"Tips and tricks"},{"url":"#dos-and-donts","title":"Do’s and don’ts"}]}]},"fields":{"slug":"/blog/2019-03-01-enterprise-scale-react-redux-project-architecture/","timeToRead":{"minutes":11.785,"words":2357}},"frontmatter":{"title":"Enterprise-scale React & Redux project architecture","authors":["Bartosz Łaniewski"],"keywords":["React","Architecture"],"language":"en","description":null,"dateCreated":"February 28, 2019","dateCreatedMeta":"2019-03-01 00:00:00 +0100","dateUpdated":"December 25, 2023","dateUpdatedMeta":"2023-12-26 00:00:00 +0100","datePublished":"February 28, 2019","datePublishedMeta":"2019-03-01 00:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/2019-03-01-enterprise-scale-react-redux-project-architecture/index.md"}}]}},"staticQueryHashes":["1271460761","3216310583","991007626"],"slicesMap":{}}