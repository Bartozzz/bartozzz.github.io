{"componentChunkName":"component---src-templates-blog-post-tsx-content-file-path-content-blog-pitfalls-of-barrel-files-in-javascript-modules-index-md","path":"/blog/pitfalls-of-barrel-files-in-javascript-modules/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://laniewski.me"}}},"pageContext":{"data":{"id":"b5bffd9c-b881-59b9-9dd2-4f093bc69ba1","body":"\nBarrel files consolidate the exports of multiple modules into a single file. We use them to import a module using a single import statement without worrying about the underlying folder structure.\n\nHave a look at the following example of a `Modal` component:\n\n```\n/components\n└── /Modal\n    ├── Modal.js\n    ├── ModalHeader.js\n    ├── ModalContent.js\n    └── ModalFooter.js\n```\n\nA barrel would be an `index.js` file at `./components/Modal` with the following definition:\n\n```js\nexport { Modal } from \"./Modal\";\nexport { ModalHeader } from \"./ModalHeader\";\nexport { ModalContent } from \"./ModalContent\";\nexport { ModalFooter } from \"./ModalFooter\";\n```\n\nIt allows us to write a single import statement, such as:\n\n```js\nimport { Modal, ModalHeader, ModalContent, ModalFooter } from \"./Modal\";\n```\n\n…instead of:\n\n```js\nimport { Modal } from \"./Modal/Modal\";\nimport { ModalHeader } from \"./Modal/ModalHeader\";\nimport { ModalContent } from \"./Modal/ModalContent\";\nimport { ModalFooter } from \"./Modal/ModalFooter\";\n```\n\nAt first glance, barrel files look promising! Barrel files can improve code organization and make imports cleaner, especially in larger projects with many modules. But there’s a hidden cost.\n\n## The bundle size cost\n\nIf you target a no-build architecture or don’t have [tree-shaking](/blog/2018-04-29-publishing-packages-to-npm/) enabled in your bundler, all the files imported in the barrel file will get bundled into the application, even when unused! It results in tons of dead code, which can impact loading times.\n\n<Alert type=\"info\">\n  Fortunately, most bundlers have tree shaking enabled by default because it reduces bundle size without changing the code behavior.\n</Alert>\n\nLet’s have a look at the following application, which renders a simple `Button` component from the [Material Design component library](https://mui.com/material-ui/):\n\n```js\nimport { Button } from \"@mui/material\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\n> node scripts/build.js\n\nCreating an optimized production build...\nCompiled successfully.\n\nFile sizes after gzip:\n\n  151.47 kB build/static/js/main.js\n```\n\nNow let’s import the `Button` component directly, skipping the barrel file:\n\n```diff\n-import { Button } from \"@mui/material\";\n+import Button from \"@mui/material/Button\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\n> node scripts/build.js\n\nCreating an optimized production build...\nCompiled successfully.\n\nFile sizes after gzip:\n\n  75.69 kB (-75.77 kB)  build/static/js/main.js\n```\n\n<Alert type=\"success\">\n  When not using a barrel file, the build size <u>decreased from ~151 kB to ~75 kB</u>.\n</Alert>\n\n## The build-time cost\n\nBarrel files are one of the key reasons why tooling is slow in bigger projects. All of your modules are likely to load barrel files (the imports are nice, after all), and so are your modules hidden behind the barrel files. It can result in a graph of import statements, where each module depends on another one, and so on.\n\nThe more files, the longer it takes for the bundler to resolve and manage them. Here are the execution times of the build script for both variants:\n\n- **With barrel file:**\n\n```js\nimport { Button } from \"@mui/material\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\nExecution time: 0h:00m:10s sec\n```\n\n- **Without barrel file:**\n\n```diff\n-import { Button } from \"@mui/material\";\n+import Button from \"@mui/material/Button\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\nExecution time: 0h:00m:7s sec\n```\n\n<Alert type=\"success\">\n  The build time is <u>30% faster</u> when not using a barrel file.<sup title=\"In a real-world scenario, the build time will probably not decrease by that much.\">*</sup>\n</Alert>\n\n## The test-time cost\n\nIn both articles (I highly recommend reading those):\n\n- [\"Why is My Jest Test Suite So Slow?\"](https://dev.to/twynsicle/why-is-my-jest-test-suite-so-slow-1od) by Steven Lemon, and\n- [\"Speeding up the JavaScript ecosystem - The barrel file debacle\"](https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7/) by Marvin Hagemeister\n\n...the conclusion is the same: barrel files slow down tests.\n\n> The problem is that Jest has no idea where the component we’re importing is located. The barrel file has intentionally obfuscated that fact. So when Jest hits a barrel file, it must load every export referenced inside it. This behavior quickly gets out of hand for large libraries like `@mui/material`. We’re looking for a single button and end up loading hundreds of additional files.\n\nLet's run the same test suite on two modules:\n\n- **Importing from barrel file:**\n\n```js\nimport { Button } from \"@mui/material\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\n> node scripts/test.js\n\n PASS  src/App.test.js\n  ✓ renders button (25 ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nTime:        1.717 s, estimated 2 s\n```\n\n- **Importing directly from the module:**\n\n```diff\n-import { Button } from \"@mui/material\";\n+import Button from \"@mui/material/Button\";\n\nexport function App() {\n  return <Button>Text</Button>;\n}\n```\n\n```\n> node scripts/test.js\n\n PASS  src/App.test.js\n  ✓ renders button (29 ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nTime:        1.097 s\n```\n\n<Alert type=\"success\">\n  The test duration <u>decreased from ~1.7 to ~1.1 seconds</u> when not importing from a barrel file.\n</Alert>\n\nNotice the test suite itself took 25-29ms. The 60ms overhead comes from building the module graph. The cost of loading modules can change depending on the machine and the tooling.\n\nIn my lab setup, 10 independent tests running in 4 child processes would result in a $$\\frac{0.6 \\times 10}{4} = 1.5$$ seconds overhead.\n\n## The lint-time cost\n\nBarrel files affect the linting performance. Let’s say you use the `import/no-cycle` rule from `eslint-plugin-import`, which ensures there is no resolvable path back to a module via its dependencies by building a dependency graph. When it comes across a barrel file, the linting time will take longer because it has to resolve all the exports from the barrel file.\n\n<Alert type=\"info\">\n  Unlike testing, linting is done on a file basis, so the dependency graph is built for each file separately.\n</Alert>\n\n## Developer experience\n\n1. Most (if not all IDEs) have autocomplete and IntelliSense - you can type the function name, and it will get the import right automatically.\n\n2. Having barrel files makes code navigation harder - <kbd>CMD + click</kbd> navigates to the barrel file instead of the actual definition of the module.\n\n## Conclusion\n\nAs software engineers, we are implementing new features daily, and each one has to be covered by _tests_. To do so, we use _linters_ to help us write better code faster. Then, we _build_ our app for a testing environment before releasing it to production (_another build_), and so on...\n\nBuilds, tests, and tooling will only get slower as the application grows. Avoiding barrel files can improve performance without compromising the architecture or the developer experience.\n","excerpt":"Barrel files consolidate the exports of multiple modules into a single file. We use them to import a module using a single import statement without…","tableOfContents":{"items":[{"url":"#the-bundle-size-cost","title":"The bundle size cost"},{"url":"#the-build-time-cost","title":"The build-time cost"},{"url":"#the-test-time-cost","title":"The test-time cost"},{"url":"#the-lint-time-cost","title":"The lint-time cost"},{"url":"#developer-experience","title":"Developer experience"},{"url":"#conclusion","title":"Conclusion"}]},"fields":{"slug":"/blog/pitfalls-of-barrel-files-in-javascript-modules/","timeToRead":{"minutes":5.26,"words":1052}},"frontmatter":{"title":"Why you should avoid Barrel Files in JavaScript Modules?","authors":["Bartosz Łaniewski"],"keywords":["JavaScript","Architecture"],"language":"en","description":null,"dateCreated":"March 27, 2024","dateCreatedMeta":"2024-03-28 00:00:00 +0100","dateUpdated":"March 27, 2024","dateUpdatedMeta":"2024-03-28 00:00:00 +0100","datePublished":"March 27, 2024","datePublishedMeta":"2024-03-28 00:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/pitfalls-of-barrel-files-in-javascript-modules/index.md"}},"frontmatter":{"title":"Why you should avoid Barrel Files in JavaScript Modules?","authors":["Bartosz Łaniewski"],"keywords":["JavaScript","Architecture"],"language":"en","dateCreated":"2024-03-28 00:00:00 +0100","dateUpdated":"2024-03-28 00:00:00 +0100","datePublished":"2024-03-28 00:00:00 +0100"}}},"staticQueryHashes":["1271460761","3216310583"],"slicesMap":{}}