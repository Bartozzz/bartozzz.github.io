{"componentChunkName":"component---src-templates-blog-post-tsx-content-file-path-content-blog-compound-components-in-react-index-md","path":"/blog/compound-components-in-react/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://laniewski.me"}}},"pageContext":{"data":{"id":"c6992986-80bd-5979-82d7-6029c505265a","body":"\nWhen building React applications, we often create components meant to be used together – think of a `Select` and an `Option` or a `Tab` and a `TabContent`. Those components have a clear relationship — they share the same design language, logic, and state. They are bound together.\n\nLet’s examine the problem with “traditional” component APIs and see how to fix them using Compound Components.\n\n## Naive (traditional) approach\n\nBuilding shared components is more challenging than creating the application itself. They will be used by all developers in your company across multiple modules you’ve probably never seen. If the component API sucks, you’ll have a hard time refactoring it. How React component APIs are designed matters in the long term. Let’s see a few examples.\n\n### The Extensibility problem\n\nI bet you’ve probably seen a `Select` component with the following API:\n\n```jsx\n<Select\n  name=\"field\"\n  options={[\n    { value: 1, label: \"Option 1\" },\n    { value: 2, label: \"Option 2\" },\n  ]}\n  value={value}\n  onChange={setValue}\n/>\n```\n\nIt takes a `name` and a list of available `options` and renders a beautiful dropdown. Pretty neat!\n\nNow, imagine you have to implement a language selection and want to show a flag near each language. We can modify the source code of the `Select` component to accept an optional `image` property and render it conditionally:\n\n```jsx {4-5}\n<Select\n  name=\"langauge\"\n  options={[\n    { value: \"pl\", label: \"Polish\", image: \"pl.png\" },\n    { value: \"fr\", label: \"French\", image: \"fr.png\" },\n  ]}\n  value={value}\n  onChange={setValue}\n/>\n```\n\nTimes fly, and so do design trends. There’s a new language to be added. Designers provided an SVG flag (as it scales better on retina displays) and want you to show a “New” badge near the value. We can add some new fields:\n\n```jsx {4}\n<Select\n  name=\"langauge\"\n  options={[\n    { value: \"it\", label: \"Italian\", icon: <ItalianFlag />, badge: <Badge>New</Badge> },\n    { value: \"pl\", label: \"Polish\", image: \"pl.png\" },\n    { value: \"fr\", label: \"French\", image: \"fr.png\" },\n  ]}\n  value={value}\n  onChange={setValue}\n/>\n```\n\n...but you see where this is going, right? Instead of leveraging composition, we have to modify the source code of the `Select` component each time a field needs stylistic customization.\n\nWhat if, instead of adding more and more properties, we could use the parent-child relationship? Think of:\n\n```jsx\n<Select name=\"langauge\" value={value} onChange={setValue}>\n  <Select.Option value=\"it\">\n    <ItalianFlag />\n    <Select.OptionLabel>Italian <Badge>New</Badge></Select.OptionLabel>\n  </Select.Option>\n\n  <Select.Option value=\"pl\">\n    <Image src=\"pl.png\" />\n    <Select.OptionLabel>Polish</Select.OptionLabel>\n  </Select.Option>\n\n  <Select.Option value=\"fr\">\n    <Image src=\"fr.png\" />\n    <Select.OptionLabel>French</Select.OptionLabel>\n  </Select.Option>\n</Select>\n```\n\n`Select` does not need to know anything about its children; it will render whatever we give it. We can render any component inside the `Select` without modifying the source code!\n\n```jsx\n<Select name=\"langauge\" value={value} onChange={setValue}>\n  <Heading>Europe</Heading>\n  <Select.Option value=\"...\">...</Select.Option>\n  <Select.Option value=\"...\">...</Select.Option>\n\n  <Divider />\n\n  <Heading>Asia</Heading>\n  <Select.Option value=\"...\">...</Select.Option>\n  <Select.Option value=\"...\">...</Select.Option>\n</Select>\n```\n\nThat approach makes the component more customizable and thus easier to maintain in the long term. In fact, with that API, we can render whatever and whenever we want. The `Select` component delegates this responsibility to you. This is called _Inversion of Control_.\n\n### The State Management problem\n\nLet's go a little bit further. Everybody knows state management is hard, and you should not do it unless you have to. What if instead of handling the component's state each time:\n\n```jsx\n<Tabs>\n  <Tabs.List>\n    <Tabs.Tab isActive={activeTabIndex === 0} onClick={() => setActiveTabIndex(0)}>Tab 1</Tabs.Tab>\n    <Tabs.Tab isActive={activeTabIndex === 1} onClick={() => setActiveTabIndex(1)}>Tab 2</Tabs.Tab>\n  <Tabs.List>\n\n  <Tabs.Content>\n    <Tabs.Panel isVisible={activeTabIndex === 0}>Content for Tab 1</Tabs.Panel>\n    <Tabs.Panel isVisible={activeTabIndex === 1}>Content for Tab 2</Tabs.Panel>\n  </Tabs.Content>\n</Tabs>\n```\n\n...the components could handle their state independently:\n\n```jsx\n<Tabs initialActiveTab={0}>\n  <Tabs.List>\n    <Tabs.Tab>Tab 1</Tabs.Tab>\n    <Tabs.Tab>Tab 2</Tabs.Tab>\n  <Tabs.List>\n\n  <Tabs.Content>\n    <Tabs.Panel>Content for Tab 1</Tabs.Panel>\n    <Tabs.Panel>Content for Tab 2</Tabs.Panel>\n  </Tabs.Content>\n</Tabs>\n```\n\n...unless we want to take the wheel:\n\n```jsx\n<Tabs activeTab={activeTabIndex} onActiveTabChange={setActiveTabIndex}>\n  <Tabs.List>\n    <Tabs.Tab>Tab 1</Tabs.Tab>\n    <Tabs.Tab>Tab 2</Tabs.Tab>\n  <Tabs.List>\n\n  <Tabs.Content>\n    <Tabs.Panel>Content for Tab 1</Tabs.Panel>\n    <Tabs.Panel>Content for Tab 2</Tabs.Panel>\n  </Tabs.Content>\n</Tabs>\n```\n\nThat would be awesome, no? With this approach, we could not only render whatever we want, whenever we want, but also not have to worry about state management!\n\n## Compound components to the rescue\n\n“Compound Components” is a React pattern where several components implicitly share a state and leverage the parent-child relationship to communicate via the [Context API](https://react.dev/learn/passing-data-deeply-with-context) in the background.\n\n### How to create a Compound Component?\n\nFirst, let’s start by creating a context that will handle all of the component state:\n\n```jsx\nconst TabsContext = createContext({});\n\nexport function Tabs({ children, initialActiveTab = 0 }) {\n  const [activeTab, onActiveTabChange] = useState(initialActiveTab);\n\n  const context = useMemo(\n    () => ({\n      activeTab,\n      onActiveTabChange,\n    }),\n    [activeTab]\n  );\n\n  return (\n    <TabsContext.Provider value={context}>{children}</TabsContext.Provider>\n  );\n}\n```\n\nThe `Tabs` component defines its state and makes it available to its children via the context. This will allow us to do state management in the background without worrying about prop drilling.\n\nThen, let’s create two components:\n- `Tabs.Tab`, which will render a button to switch the current tab:\n\n    ```jsx\n    Tabs.Tab = function TabsTab({ children, isActive, onClick }) {\n      return <button onClick={onClick}>{children}</button>;\n    };\n    ```\n\n- `Tabs.Panel`, which will render the content if the tab is selected:\n\n    ```jsx\n    Tabs.Panel = function TabsPanel({ children, isVisible }) {\n      return isVisible ? children : null;\n    };\n    ```\n\nTo glue all the components together, let’s create `Tabs.List` and `Tabs.Content` components. Those components will read from the context and populate their children with properties.\n\n```tsx\nTabs.List = function TabsList({ children }) {\n  const { activeTab, onActiveTabChange } = useContext(TabsContext);\n\n  return React.Children.map(children, (child, index) => (\n    React.cloneElement(child, {\n      isActive: activeTab === index,\n      onClick: () => onActiveTabChange(index),\n    })\n  ));\n};\n\nTabs.Content = function TabsContent({ children }) {\n  const { activeTab } = useContext(TabsContext);\n\n  return React.Children.map(children, (child, index) => (\n    React.cloneElement(child, {\n      isVisible: activeTab === index,\n    })\n  ));\n};\n```\n\nAs you can see, both components iterate over their children and clone them to provide additional properties from the context to fulfill the children’s interfaces.\n\n### How to make a Compound Component controlled?\n\nOur `Tabs` component is [uncontrolled](https://react.dev/learn/sharing-state-between-components#controlled-and-uncontrolled-components); it manages its state on its own. We can extend it to become controlled.\n\nLet’s start by writing a helper hook that will help us manage the state in a safe manner for both controlled and uncontrolled components:\n\n```js\nfunction useControlled({ value, initialValue }) {\n  const { current: isUncontrolled } = useRef(value === undefined);\n\n  const [localValue, setLocalValue] = useState(initialValue);\n\n  const safeValue = isUncontrolled ? localValue : value;\n  const safeSetValue = useCallback((newValue) => {\n    if (isUncontrolled) {\n      setLocalValue(newValue);\n    }\n  }, []);\n\n  return [safeValue, safeSetValue];\n}\n```\n\nNow, we can use this hook as follows to make our `Tabs` a controlled or uncontrolled component at will:\n\n```jsx {4-7, 9-12, 14-21}\nconst TabsContext = createContext({});\n\nexport function Tabs({ children, initialActiveTab = 0, activeTab, onActiveTabChange }) {\n  const [value, onValueChange] = useControlled({\n    value: activeTab,\n    initialValue: initialActiveTab\n  });\n\n  const handleValueChange = useCallback((newValue) => {\n    onValueChange(newValue);\n    onActiveTabChange?.(newValue);\n  }, [onValueChange, onActiveTabChange]);\n\n  const context = useMemo(\n    () => ({\n      activeTab: value,\n      onActiveTabChange: handleValueChange,\n    }),\n    [value, handleValueChange]\n  );\n\n  return (\n    <TabsContext.Provider value={context}>{children}</TabsContext.Provider>\n  );\n}\n```\n","excerpt":"When building React applications, we often create components meant to be used together – think of a Select and an Option or a Tab and a TabContent. Those…","tableOfContents":{"items":[{"url":"#naive-traditional-approach","title":"Naive (traditional) approach","items":[{"url":"#the-extensibility-problem","title":"The Extensibility problem"},{"url":"#the-state-management-problem","title":"The State Management problem"}]},{"url":"#compound-components-to-the-rescue","title":"Compound components to the rescue","items":[{"url":"#how-to-create-a-compound-component","title":"How to create a Compound Component?"},{"url":"#how-to-make-a-compound-component-controlled","title":"How to make a Compound Component controlled?"}]}]},"fields":{"slug":"/blog/compound-components-in-react/","timeToRead":{"minutes":5.645,"words":1129}},"frontmatter":{"title":"How to write better React with Compound Components?","authors":["Bartosz Łaniewski"],"keywords":["React","Architecture"],"language":"en","description":null,"dateCreated":"April 07, 2024","dateCreatedMeta":"2024-04-07 12:00:00 +0100","dateUpdated":"April 22, 2024","dateUpdatedMeta":"2024-04-22 15:00:00 +0100","datePublished":"April 22, 2024","datePublishedMeta":"2024-04-22 15:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/compound-components-in-react/index.md"}},"frontmatter":{"title":"How to write better React with Compound Components?","authors":["Bartosz Łaniewski"],"keywords":["React","Architecture"],"language":"en","dateCreated":"2024-04-07 12:00:00 +0100","dateUpdated":"2024-04-22 15:00:00 +0100","datePublished":"2024-04-22 15:00:00 +0100"}}},"staticQueryHashes":["1271460761","3216310583"],"slicesMap":{}}