{"componentChunkName":"component---src-templates-blog-post-tsx-content-file-path-content-blog-2022-06-27-case-study-filler-index-md","path":"/blog/2022-06-27-case-study-filler/","result":{"data":{"site":{"siteMetadata":{"siteUrl":"https://laniewski.me"}}},"pageContext":{"data":{"id":"683df14a-e3e7-5b97-834b-d4071070c06a","body":"\n[Filler](https://filler.laniewski.me/) is the first mobile game I ever created with React Native. It started as an experiment to learn more about algorithms, animations, and the platform itself.\n\n## Introduction\n\nI initially created Filler when I was ~15 years old. The idea came up as I was thinking of simple projects I could work on to learn more about web development and data structures. It was later on that I learned there was already a similar (and quite popular back in the ’90s) game, called _\"Lights Out\"_.\n\n> Lights Out is an electronic game released by Tiger Electronics in 1995. The game consists of a 5 by 5 grid of lights. When the game starts, a random number or a stored pattern of these lights is switched on. Pressing any of the lights will toggle it and the adjacent lights. The goal of the puzzle is to switch all the lights off, preferably in as few button presses as possible. – [Wikipedia](https://en.wikipedia.org/wiki/Lights_Out_(game))\n\nThere are, however, a few differences between the original and my game. In Filler:\n1. grids can be of any size, not only $$5 \\times 5$$;\n2. the goal is to switch all the lights on, not off;\n\nThe technology stack is pretty standard for the React ecosystem:\n\n- [Expo](https://expo.dev/)\n- [TypeScript](https://www.typescriptlang.org/)\n- [React Navigation](https://reactnavigation.org/)\n- [Styled Components](https://styled-components.com/)\n\n## Development\n\n### Internationalization\n\nI used [`expo-localization`](https://docs.expo.dev/versions/latest/sdk/localization/) and [`i18n-js`](https://github.com/fnando/i18n-js) to localize my application. The internationalization setup is pretty straightforward:\n\n```ts\nimport * as Localization from \"expo-localization\";\nimport i18n from \"i18n-js\";\n\nimport en from \"./strings/en.json\";\nimport fr from \"./strings/fr.json\";\nimport pl from \"./strings/pl.json\";\n\ni18n.fallbacks = true;\ni18n.translations = { en, pl, fr };\ni18n.defaultLocale = \"en\";\ni18n.locale = Localization.locale;\n\nexport { i18n };\n```\n\n…then, I could simply import `i18n` and use it in the application as follows:\n\n```tsx\n<Button>{i18n.t(\"menu.campaignButton\")}</Button>\n```\n\nTo make my tests independent of the translations, I mocked the `i18n-js` library and made the `i18n.t` function return the translation key instead of the translation itself:\n\n```ts\njest.mock(\"i18n-js\", () => {\n  return {\n    ...jest.requireActual(\"i18n-js\"),\n    t: jest.fn((key) => key),\n  };\n});\n```\n\n…having that, I could safely update the copy without breaking the integration tests:\n\n```tsx\nit(\"should reset the board on ’Reset’ button click\", () => {\n  const view = render(<Game />);\n\n  fireEvent.press(view.getByText(\"header.resetBtn\"));\n  // …\n});\n```\n\nI was not afraid to break anything in the user interface because my application contains visual regression tests. It allows me to ensure that my application appears to the end-user as it was originally intended to and I can catch visual regressions with ease.\n\n<Newsletter />\n\n### Animations\n\nI used [`react-native-reanimated`](https://github.com/software-mansion/react-native-reanimated) to create all animations in the game. The main reason behind this choice was that the animations run on the native thread – it’s a great animation library performance-wise. It comes with an imperative and a declarative API.\n\n#### Imperative API\n\nI used the imperative functions and hooks for the `GridCell` component. I wanted to interpolate between two colors based on the `checked` prop. It was possible thanks to the `interpolateColor` helper:\n\n```tsx {2, 5-11, 15}\nfunction GridCell({ checked }: { checked: boolean }) {\n  const colorProgress = useSharedValue(checked ? 1 : 0);\n\n  // Interpolate between `empty` and `checked` color based on progress:\n  const animatedStyles = useAnimatedStyle(() => ({\n    backgroundColor: interpolateColor(\n      colorProgress.value,\n      [0, 1],\n      [theme.emptyCellColor, theme.checkedCellColor]\n    ),\n  }), [theme, colorProgress]);\n\n  // Change progress to 0-1 on `checked` change:\n  React.useEffect(() => {\n    colorProgress.value = withTiming(checked ? 1 : 0);\n  }, [checked, colorProgress]);\n\n  return <Cell style={animatedStyles} />\n}\n```\n\n#### Declarative API\n\nThere’s also a higher-level API that I used to progressively reveal content on the success screen. I didn’t need anything fancy here, just some entering animations with delays and the declarative API does a great job for such things:\n\n```tsx {6, 10, 14}\nfunction ScoreStars({ score }: { score: number }) {\n  const delay = 250;\n\n  return (\n    <Stars>\n      <Animated.View entering={Swing.delay(delay * 0)}>\n        {score < 1 ? <GrayStar /> : <GoldStar />}\n      </Animated.View>\n\n      <Animated.View entering={Swing.delay(delay * 1)}>\n        {score < 2 ? <GrayStar /> : <GoldStar />}\n      </Animated.View>\n\n      <Animated.View entering={Swing.delay(delay * 2)}>\n        {score < 3 ? <GrayStar /> : <GoldStar />}\n      </Animated.View>\n    </Stars>\n  );\n};\n```\n\n…where `Swing` is a custom [keyframe](https://docs.swmansion.com/react-native-reanimated/docs/2.x/api/LayoutAnimations/keyframeAnimations/) I created:\n\n```tsx\nconst Swing = () =>\n  new Keyframe({\n    0: { transform: [{ rotate: \"0deg\" }] },\n    20: { transform: [{ rotate: \"15deg\" }] },\n    40: { transform: [{ rotate: \"-10deg\" }] },\n    60: { transform: [{ rotate: \"5deg\" }] },\n    80: { transform: [{ rotate: \"-5deg\" }] },\n    100: { transform: [{ rotate: \"0deg\" }] },\n  });\n```\n\n### Monetization\n\nAfter the gameplay was implemented, I started working on integrating ads into the application using Google’s AdMob platform. The monetization model is pretty standard in the mobile industry. I decided to show:\n- an Interstitial Ad when the user completes a level (cap at 1 impression every 5 minutes per user);\n- a Rewarded Ad to unlock the solution w/ solver.\n\nI used [`react-native-google-mobile-ads`](https://github.com/invertase/react-native-google-mobile-ads) (and had a chance to contribute a little bit to the library as well!) to implement the advertising.\n\n#### Interstitial Ad\n\nI created a hook to easily check whether the advertisement has been watched or not.\n\n```tsx\nfunction useInterstitialAd() {\n  const { isLoaded, isClosed, error, load, show } = nativeUseInterstitialAd(\n    \"<AD_UNIT_ID>\",\n    {\n      requestNonPersonalizedAdsOnly: true,\n    }\n  );\n\n  const isError = error !== undefined;\n  const isAdWatched = isClosed || isError;\n\n  // Start loading the interstitial straight away:\n  React.useEffect(() => {\n    load();\n  }, [load]);\n\n  // Show the interstitial once loaded:\n  React.useEffect(() => {\n    if (isLoaded) {\n      show();\n    }\n  }, [isLoaded, show]);\n\n  return { isAdWatched };\n}\n```\n\n…then, I could very simply disable the \"Next level\" button until the ad has been watched:\n\n```tsx\nconst { isAdWatched } = useInterstitialAd();\n\n<Button disabled={!isAdWatched} onPress={handleExit}>\n  Next level\n</Button>\n```\n\n#### Rewarded Ad\n\nRewarded ads need a trigger and an explicit user interaction to show. I decided to go with a React Render Props pattern for a nice DX:\n\n```tsx\n<RewardedAd onSuccess={showSolution}>\n  {({ trigger, isAdLoading }) => (\n    <ActionButton onPress={trigger} processing={isAdLoading}>\n      Show solution\n    </ActionButton>\n  )}\n</RewardedAd>\n```\n\n`RewardedAd` hides a lot of boilerplate, but basically, it listens for events and handles the various errors that can occur.\n\n## Challenges\n\n### Permissions\n\n<Alert type=\"warning\">\n\nBy default, Expo adds a lot of unnecessary permission which can discourage the user from installing your application.\n</Alert>\n\nOnce released on Google Play, I noticed that the app had unnecessary permission listed. It required pretty much every permission available but needed none to work. To remove unused permissions, I had to modify `android/app/src/main/AndroidManifest.xml` as follows (note the `tools:node=\"remove\"` on `uses-permission`):\n\n```xml\n<manifest xmlns:tools=\"http://schemas.android.com/tools\" xmlns:android=\"http://schemas.android.com/apk/res/android\">\n  <uses-permission android:name=\"android.permission.VIBRATE\" />\n  <uses-permission android:name=\"android.permission.INTERNET\" />\n  <uses-permission tools:node=\"remove\" android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" />\n  <uses-permission tools:node=\"remove\" android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n  <uses-permission tools:node=\"remove\" android:name=\"android.permission.READ_PHONE_STATE\" />\n  <uses-permission tools:node=\"remove\" android:name=\"android.permission.RECORD_AUDIO\" />\n  <uses-permission tools:node=\"remove\" android:name=\"android.permission.SYSTEM_ALERT_WINDOW\" />\n  <uses-permission tools:node=\"remove\" android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n</manifest>\n```\n\n### Performance\n\nI use my old [Asus ZenFone 3 Max 5.2](https://www.gsmchoice.com/en/catalogue/asus/zenfone3maxzc520tl/) as a benchmark – if a game works nicely on this device, I can sleep soundly because it means it will run on pretty much anything. My aim I always to get a stable 60 FPS for a nice user experience.\n\nIt was quite hard to achieve at first for several reasons:\n1. **Initially, I used [`react-native-animatable`](https://github.com/oblador/react-native-animatable) for animations:** it had noticeably worse performance than `react-native-reanimated`;\n2. **There were some redundant re-renders:** once I memorized some expensive components and calculation results, it improved the performance;\n3. **I was using JSC instead of [Hermes](https://engineering.fb.com/2019/07/12/android/hermes/):** once I migrated to Hermes, the performance improved greatly. Also, <abbr title=\"Time to Interaction\">TTI</abbr>, application size and memory utilization decreased a lot;\n\nIt turned out that React Native with Hermes can perform well enough to provide a nice UX, even on my old phone.\n\n### Sounds\n\nThere’s an issue with playing the same [`Audio`](https://docs.expo.dev/versions/latest/sdk/audio/) multiple times: the sound works well the first time, but the other times it seems that the sound isn’t playing from the start but has a shift of some milliseconds.\n\nThe solution I use is to preload multiple copies of [`Audio`](https://docs.expo.dev/versions/latest/sdk/audio/) and play the next sample when needed. My implementation looks as follows:\n\n```ts\nimport { Audio } from \"expo-av\";\nimport { AVPlaybackSource } from \"expo-av/build/AV\";\n\nclass Sound {\n  static COPIES = 3;\n  static INDEX = 0;\n  static assets: Record<string, Audio.Sound> = {};\n\n  static loadAsync(library: Record<string, AVPlaybackSource>) {\n    const promisesForCopies = Object.entries(library).flatMap(\n      ([name, path]: [string, AVPlaybackSource]) => {\n        // Make n = Sound.COPIES copies:\n        return Array.from(Array(Sound.COPIES)).map((_, i) => {\n          const soundNameWithIndex = `${name}-${i}`;\n\n          Sound.assets[soundNameWithIndex] = new Audio.Sound();\n          return Sound.assets[soundNameWithIndex].loadAsync(path);\n        });\n      }\n    );\n\n    return Promise.all(promisesForCopies);\n  }\n\n  static async play(name: string, volume = 1) {\n    try {\n      Sound.INDEX = (Sound.INDEX + 1) % Sound.COPIES;\n\n      const soundNameWithIndex = `${name}-${Sound.INDEX}`;\n      const soundSample = Sound.assets[soundNameWithIndex];\n\n      if (soundSample) {\n        await soundSample.setVolumeAsync(volume);\n        await soundSample.playFromPositionAsync(0);\n      } else {\n        throw new Error(`Sound ${name} does not exist`);\n      }\n    } catch (error) {\n      // Silent error…\n    }\n  }\n}\n```\n\n### Solver\n\nI wanted to create a solver to monetize the game. It turned out to be quite a popular problem with a lot of resources online, so I won’t go into much detail. It just required a bit of linear algebra.\n\nA board can be modeled mathematically as a vector over $$\\mathbb{F}_2$$, a [field](https://en.wikipedia.org/wiki/GF(2)) containing only the elements 0 and 1 (for light on and off respectively). We can write each possible board position and each possible move as a vector over $$\\mathbb{F}_2$$. That means that:\n- pressing a cell an even number of times has no effect;\n- the order in which we press the cells does not matter;\n\nTo solve the board, we need to find a combination of these move vectors which adds up to give the current board, since that will cancel with the board, turning all of the lights on. There is a systematic way of solving this kind of vector problem called [Gaussian Elimination](https://en.wikipedia.org/wiki/Gaussian_elimination).\n\n```ts\nfunction solve(width: number, height: number, state: boolean[]): number[] {\n  const moveVector = buildMoveVector(width, height);\n  const moveMatrix = buildMoveMatrix(moveVector, state);\n  const solution = getLastRow(rref(moveMatrix));\n\n  return solution;\n}\n```\n\nA nice video explaining this in detail can be found [here](https://www.youtube.com/watch?v=oCHCD_-nhg4).\n\n## Conclusion\n\nIt was a fun experience to rebuild the same game several years later after gathering all of my commercial experience and still being able to learn new things along the journey. So far, I’ve got 200+ downloads and generated $0.20 in ad revenue, but hey, the learnings are priceless!\n","excerpt":"Filler is the first mobile game I ever created with React Native. It started as an experiment to learn more about algorithms, animations, and the platform…","tableOfContents":{"items":[{"url":"#introduction","title":"Introduction"},{"url":"#development","title":"Development","items":[{"url":"#internationalization","title":"Internationalization"},{"url":"#animations","title":"Animations"},{"url":"#monetization","title":"Monetization"}]},{"url":"#challenges","title":"Challenges","items":[{"url":"#permissions","title":"Permissions"},{"url":"#performance","title":"Performance"},{"url":"#sounds","title":"Sounds"},{"url":"#solver","title":"Solver"}]},{"url":"#conclusion","title":"Conclusion"}]},"fields":{"slug":"/blog/2022-06-27-case-study-filler/","timeToRead":{"minutes":8.53,"words":1706}},"frontmatter":{"title":"Case study: Filler (a React Native game)","authors":["Bartosz Łaniewski"],"keywords":["Case Study","Gamedev","React Native"],"language":"en","description":null,"dateCreated":"June 26, 2022","dateCreatedMeta":"2022-06-27 00:00:00 +0100","dateUpdated":"December 25, 2023","dateUpdatedMeta":"2023-12-26 00:00:00 +0100","datePublished":"June 26, 2022","datePublishedMeta":"2022-06-27 00:00:00 +0100"},"internal":{"contentFilePath":"/home/runner/work/bartozzz.github.io/bartozzz.github.io/content/blog/2022-06-27-case-study-filler/index.md"}},"frontmatter":{"title":"Case study: Filler (a React Native game)","authors":["Bartosz Łaniewski"],"keywords":["Case Study","Gamedev","React Native"],"language":"en","dateCreated":"2022-06-27 00:00:00 +0100","dateUpdated":"2023-12-26 00:00:00 +0100","datePublished":"2022-06-27 00:00:00 +0100"}}},"staticQueryHashes":["1271460761","3216310583"],"slicesMap":{}}